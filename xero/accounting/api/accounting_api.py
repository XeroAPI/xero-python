"""
    Xero Accounting API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 6.3.0
    Contact: api@xero.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import importlib
import io
import re  # noqa: F401
from datetime import date, datetime
from typing import Optional, Union

from pydantic import (
    Field,
    StrictBool,
    StrictBytes,
    StrictInt,
    StrictStr,
    conlist,
)
from typing_extensions import Annotated

from xero.accounting.models.account import Account
from xero.accounting.models.accounts import Accounts
from xero.accounting.models.actions import Actions
from xero.accounting.models.allocation import Allocation
from xero.accounting.models.allocations import Allocations
from xero.accounting.models.attachments import Attachments
from xero.accounting.models.bank_transactions import BankTransactions
from xero.accounting.models.bank_transfers import BankTransfers
from xero.accounting.models.batch_payment_delete import BatchPaymentDelete
from xero.accounting.models.batch_payment_delete_by_url_param import (
    BatchPaymentDeleteByUrlParam,
)
from xero.accounting.models.batch_payments import BatchPayments
from xero.accounting.models.branding_themes import BrandingThemes
from xero.accounting.models.budgets import Budgets
from xero.accounting.models.cis_org_settings import CISOrgSettings
from xero.accounting.models.cis_settings import CISSettings
from xero.accounting.models.contact_groups import ContactGroups
from xero.accounting.models.contacts import Contacts
from xero.accounting.models.credit_notes import CreditNotes
from xero.accounting.models.currencies import Currencies
from xero.accounting.models.currency import Currency
from xero.accounting.models.employees import Employees
from xero.accounting.models.expense_claims import ExpenseClaims
from xero.accounting.models.history_records import HistoryRecords
from xero.accounting.models.import_summary_object import ImportSummaryObject
from xero.accounting.models.invoice_reminders import InvoiceReminders
from xero.accounting.models.invoices import Invoices
from xero.accounting.models.items import Items
from xero.accounting.models.journals import Journals
from xero.accounting.models.linked_transaction import LinkedTransaction
from xero.accounting.models.linked_transactions import LinkedTransactions
from xero.accounting.models.manual_journals import ManualJournals
from xero.accounting.models.online_invoices import OnlineInvoices
from xero.accounting.models.organisations import Organisations
from xero.accounting.models.overpayments import Overpayments
from xero.accounting.models.payment import Payment
from xero.accounting.models.payment_delete import PaymentDelete
from xero.accounting.models.payment_services import PaymentServices
from xero.accounting.models.payments import Payments
from xero.accounting.models.prepayments import Prepayments
from xero.accounting.models.purchase_orders import PurchaseOrders
from xero.accounting.models.quotes import Quotes
from xero.accounting.models.receipts import Receipts
from xero.accounting.models.repeating_invoices import RepeatingInvoices
from xero.accounting.models.report_with_rows import ReportWithRows
from xero.accounting.models.reports import Reports
from xero.accounting.models.request_empty import RequestEmpty
from xero.accounting.models.setup import Setup
from xero.accounting.models.tax_rates import TaxRates
from xero.accounting.models.tracking_categories import TrackingCategories
from xero.accounting.models.tracking_category import TrackingCategory
from xero.accounting.models.tracking_option import TrackingOption
from xero.accounting.models.tracking_options import TrackingOptions
from xero.accounting.models.users import Users
from xero.api_client import ApiClient, ApiResponse, ModelFinder
from xero.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError,
)


class AccountingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    base_url = "https://api.xero.com/api.xro/2.0"
    models_module = importlib.import_module("xero.accounting.models")

    def __init__(self, api_client=None, base_url: str | None = None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client
        self.base_url = base_url or self.base_url

    def get_model_finder(self):
        return ModelFinder(self.models_module)

    async def create_account(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account: Annotated[
            Account, Field(..., description="Account object in body of request")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Accounts:  # noqa: E501
        """Creates a new chart of accounts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account: Account object in body of request (required)
        :type account: Account
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Accounts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_account_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_account_with_http_info(
            xero_tenant_id, account, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_account_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account: Annotated[
            Account, Field(..., description="Account object in body of request")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new chart of accounts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account: Account object in body of request (required)
        :type account: Account
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "account", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_account" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["account"] is not None:
            _body_params = _params["account"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Accounts",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Accounts",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_account_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Creates an attachment on a specific account  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_account_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_account_attachment_by_file_name_with_http_info(
            xero_tenant_id, account_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_account_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an attachment on a specific account  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "account_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_account_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["AccountID"] = _params["account_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Accounts/{AccountID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_bank_transaction_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Creates an attachment for a specific bank transaction by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_bank_transaction_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return (
            await self.create_bank_transaction_attachment_by_file_name_with_http_info(
                xero_tenant_id,
                bank_transaction_id,
                file_name,
                body,
                idempotency_key,
                **kwargs,
            )
        )  # noqa: E501

    async def create_bank_transaction_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an attachment for a specific bank transaction by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transaction_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transaction_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transaction_id"] is not None:
            _path_params["BankTransactionID"] = _params["bank_transaction_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransactions/{BankTransactionID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_bank_transaction_history_record(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific bank transactions  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_bank_transaction_history_record_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_bank_transaction_history_record_with_http_info(
            xero_tenant_id,
            bank_transaction_id,
            history_records,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_bank_transaction_history_record_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific bank transactions  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transaction_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transaction_history_record" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transaction_id"] is not None:
            _path_params["BankTransactionID"] = _params["bank_transaction_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransactions/{BankTransactionID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_bank_transactions(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transactions: Annotated[
            BankTransactions,
            Field(
                ...,
                description="BankTransactions with an array of BankTransaction objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> BankTransactions:  # noqa: E501
        """Creates one or more spent or received money transaction  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transactions: BankTransactions with an array of BankTransaction objects in body of request (required)
        :type bank_transactions: BankTransactions
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BankTransactions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_bank_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_bank_transactions_with_http_info(
            xero_tenant_id,
            bank_transactions,
            summarize_errors,
            unitdp,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_bank_transactions_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transactions: Annotated[
            BankTransactions,
            Field(
                ...,
                description="BankTransactions with an array of BankTransaction objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates one or more spent or received money transaction  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transactions: BankTransactions with an array of BankTransaction objects in body of request (required)
        :type bank_transactions: BankTransactions
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BankTransactions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transactions",
            "summarize_errors",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transactions" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["bank_transactions"] is not None:
            _body_params = _params["bank_transactions"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BankTransactions",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransactions",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_bank_transfer(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfers: Annotated[
            BankTransfers,
            Field(
                ...,
                description="BankTransfers with array of BankTransfer objects in request body",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> BankTransfers:  # noqa: E501
        """Creates a bank transfer  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfers: BankTransfers with array of BankTransfer objects in request body (required)
        :type bank_transfers: BankTransfers
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BankTransfers
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_bank_transfer_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_bank_transfer_with_http_info(
            xero_tenant_id, bank_transfers, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_bank_transfer_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfers: Annotated[
            BankTransfers,
            Field(
                ...,
                description="BankTransfers with array of BankTransfer objects in request body",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a bank transfer  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfers: BankTransfers with array of BankTransfer objects in request body (required)
        :type bank_transfers: BankTransfers
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BankTransfers, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "bank_transfers", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transfer" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["bank_transfers"] is not None:
            _body_params = _params["bank_transfers"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BankTransfers",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransfers",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_bank_transfer_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """create_bank_transfer_attachment_by_file_name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_bank_transfer_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_bank_transfer_attachment_by_file_name_with_http_info(
            xero_tenant_id, bank_transfer_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_bank_transfer_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """create_bank_transfer_attachment_by_file_name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transfer_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transfer_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transfer_id"] is not None:
            _path_params["BankTransferID"] = _params["bank_transfer_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransfers/{BankTransferID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_bank_transfer_history_record(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific bank transfer  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_bank_transfer_history_record_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_bank_transfer_history_record_with_http_info(
            xero_tenant_id, bank_transfer_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_bank_transfer_history_record_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific bank transfer  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transfer_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transfer_history_record" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transfer_id"] is not None:
            _path_params["BankTransferID"] = _params["bank_transfer_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransfers/{BankTransferID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_batch_payment(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payments: Annotated[
            BatchPayments,
            Field(
                ...,
                description="BatchPayments with an array of Payments in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> BatchPayments:  # noqa: E501
        """Creates one or many batch payments for invoices  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payments: BatchPayments with an array of Payments in body of request (required)
        :type batch_payments: BatchPayments
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BatchPayments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_batch_payment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_batch_payment_with_http_info(
            xero_tenant_id, batch_payments, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_batch_payment_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payments: Annotated[
            BatchPayments,
            Field(
                ...,
                description="BatchPayments with an array of Payments in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates one or many batch payments for invoices  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payments: BatchPayments with an array of Payments in body of request (required)
        :type batch_payments: BatchPayments
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BatchPayments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "batch_payments",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_batch_payment" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["batch_payments"] is not None:
            _body_params = _params["batch_payments"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BatchPayments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BatchPayments",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_batch_payment_history_record(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for BatchPayment")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific batch payment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_id: Unique identifier for BatchPayment (required)
        :type batch_payment_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_batch_payment_history_record_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_batch_payment_history_record_with_http_info(
            xero_tenant_id, batch_payment_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_batch_payment_history_record_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for BatchPayment")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific batch payment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_id: Unique identifier for BatchPayment (required)
        :type batch_payment_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "batch_payment_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_batch_payment_history_record" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["batch_payment_id"] is not None:
            _path_params["BatchPaymentID"] = _params["batch_payment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BatchPayments/{BatchPaymentID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_branding_theme_payment_services(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        branding_theme_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Branding Theme")
        ],
        payment_services: Annotated[
            PaymentServices,
            Field(
                ...,
                description="PaymentServices array with PaymentService object in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PaymentServices:  # noqa: E501
        """Creates a new custom payment service for a specific branding theme  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param branding_theme_id: Unique identifier for a Branding Theme (required)
        :type branding_theme_id: str
        :param payment_services: PaymentServices array with PaymentService object in body of request (required)
        :type payment_services: PaymentServices
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaymentServices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_branding_theme_payment_services_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_branding_theme_payment_services_with_http_info(
            xero_tenant_id,
            branding_theme_id,
            payment_services,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_branding_theme_payment_services_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        branding_theme_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Branding Theme")
        ],
        payment_services: Annotated[
            PaymentServices,
            Field(
                ...,
                description="PaymentServices array with PaymentService object in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new custom payment service for a specific branding theme  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param branding_theme_id: Unique identifier for a Branding Theme (required)
        :type branding_theme_id: str
        :param payment_services: PaymentServices array with PaymentService object in body of request (required)
        :type payment_services: PaymentServices
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaymentServices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "branding_theme_id",
            "payment_services",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_branding_theme_payment_services" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["branding_theme_id"] is not None:
            _path_params["BrandingThemeID"] = _params["branding_theme_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["payment_services"] is not None:
            _body_params = _params["payment_services"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PaymentServices",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BrandingThemes/{BrandingThemeID}/PaymentServices",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_contact_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """create_contact_attachment_by_file_name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_contact_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_contact_attachment_by_file_name_with_http_info(
            xero_tenant_id, contact_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_contact_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """create_contact_attachment_by_file_name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "contact_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_contact_group(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_groups: Annotated[
            ContactGroups,
            Field(
                ..., description="ContactGroups with an array of names in request body"
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ContactGroups:  # noqa: E501
        """Creates a contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_groups: ContactGroups with an array of names in request body (required)
        :type contact_groups: ContactGroups
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContactGroups
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_contact_group_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_contact_group_with_http_info(
            xero_tenant_id, contact_groups, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_contact_group_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_groups: Annotated[
            ContactGroups,
            Field(
                ..., description="ContactGroups with an array of names in request body"
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_groups: ContactGroups with an array of names in request body (required)
        :type contact_groups: ContactGroups
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ContactGroups, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_groups", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact_group" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["contact_groups"] is not None:
            _body_params = _params["contact_groups"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ContactGroups",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ContactGroups",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_contact_group_contacts(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        contacts: Annotated[
            Contacts,
            Field(
                ...,
                description="Contacts with array of contacts specifying the ContactID to be added to ContactGroup in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Contacts:  # noqa: E501
        """Creates contacts to a specific contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param contacts: Contacts with array of contacts specifying the ContactID to be added to ContactGroup in body of request (required)
        :type contacts: Contacts
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Contacts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_contact_group_contacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_contact_group_contacts_with_http_info(
            xero_tenant_id, contact_group_id, contacts, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_contact_group_contacts_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        contacts: Annotated[
            Contacts,
            Field(
                ...,
                description="Contacts with array of contacts specifying the ContactID to be added to ContactGroup in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates contacts to a specific contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param contacts: Contacts with array of contacts specifying the ContactID to be added to ContactGroup in body of request (required)
        :type contacts: Contacts
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "contact_group_id",
            "contacts",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact_group_contacts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_group_id"] is not None:
            _path_params["ContactGroupID"] = _params["contact_group_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["contacts"] is not None:
            _body_params = _params["contacts"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Contacts",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ContactGroups/{ContactGroupID}/Contacts",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_contact_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a new history record for a specific contact  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_contact_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_contact_history_with_http_info(
            xero_tenant_id, contact_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_contact_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new history record for a specific contact  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "contact_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_contacts(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contacts: Annotated[
            Contacts,
            Field(
                ...,
                description="Contacts with an array of Contact objects to create in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Contacts:  # noqa: E501
        """Creates multiple contacts (bulk) in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contacts: Contacts with an array of Contact objects to create in body of request (required)
        :type contacts: Contacts
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Contacts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_contacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_contacts_with_http_info(
            xero_tenant_id, contacts, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_contacts_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contacts: Annotated[
            Contacts,
            Field(
                ...,
                description="Contacts with an array of Contact objects to create in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates multiple contacts (bulk) in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contacts: Contacts with an array of Contact objects to create in body of request (required)
        :type contacts: Contacts
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "contacts",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contacts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["contacts"] is not None:
            _body_params = _params["contacts"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Contacts",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Contacts",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_credit_note_allocation(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        allocations: Annotated[
            Allocations,
            Field(
                ...,
                description="Allocations with array of Allocation object in body of request.",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Allocations:  # noqa: E501
        """Creates allocation for a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param allocations: Allocations with array of Allocation object in body of request. (required)
        :type allocations: Allocations
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Allocations
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_credit_note_allocation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_credit_note_allocation_with_http_info(
            xero_tenant_id,
            credit_note_id,
            allocations,
            summarize_errors,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_credit_note_allocation_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        allocations: Annotated[
            Allocations,
            Field(
                ...,
                description="Allocations with array of Allocation object in body of request.",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates allocation for a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param allocations: Allocations with array of Allocation object in body of request. (required)
        :type allocations: Allocations
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Allocations, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "credit_note_id",
            "allocations",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_credit_note_allocation" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["allocations"] is not None:
            _body_params = _params["allocations"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Allocations",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/Allocations",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_credit_note_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        include_online: Annotated[
            Optional[StrictBool],
            Field(
                description="Allows an attachment to be seen by the end customer within their online invoice"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Creates an attachment for a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param include_online: Allows an attachment to be seen by the end customer within their online invoice
        :type include_online: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_credit_note_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_credit_note_attachment_by_file_name_with_http_info(
            xero_tenant_id,
            credit_note_id,
            file_name,
            body,
            include_online,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_credit_note_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        include_online: Annotated[
            Optional[StrictBool],
            Field(
                description="Allows an attachment to be seen by the end customer within their online invoice"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an attachment for a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param include_online: Allows an attachment to be seen by the end customer within their online invoice
        :type include_online: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "credit_note_id",
            "file_name",
            "body",
            "include_online",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_credit_note_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        if _params.get("include_online") is not None:  # noqa: E501
            _query_params.append(("IncludeOnline", _params["include_online"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_credit_note_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history records of a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_credit_note_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_credit_note_history_with_http_info(
            xero_tenant_id, credit_note_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_credit_note_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history records of a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "credit_note_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_credit_note_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_credit_notes(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_notes: Annotated[
            CreditNotes,
            Field(
                ...,
                description="Credit Notes with array of CreditNote object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> CreditNotes:  # noqa: E501
        """Creates a new credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_notes: Credit Notes with array of CreditNote object in body of request (required)
        :type credit_notes: CreditNotes
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreditNotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_credit_notes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_credit_notes_with_http_info(
            xero_tenant_id,
            credit_notes,
            summarize_errors,
            unitdp,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_credit_notes_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_notes: Annotated[
            CreditNotes,
            Field(
                ...,
                description="Credit Notes with array of CreditNote object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_notes: Credit Notes with array of CreditNote object in body of request (required)
        :type credit_notes: CreditNotes
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreditNotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "credit_notes",
            "summarize_errors",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_credit_notes" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["credit_notes"] is not None:
            _body_params = _params["credit_notes"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "CreditNotes",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/CreditNotes",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_currency(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        currency: Annotated[
            Currency, Field(..., description="Currency object in the body of request")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Currencies:  # noqa: E501
        """Create a new currency for a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param currency: Currency object in the body of request (required)
        :type currency: Currency
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Currencies
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_currency_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_currency_with_http_info(
            xero_tenant_id, currency, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_currency_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        currency: Annotated[
            Currency, Field(..., description="Currency object in the body of request")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Create a new currency for a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param currency: Currency object in the body of request (required)
        :type currency: Currency
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Currencies, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "currency", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_currency" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["currency"] is not None:
            _body_params = _params["currency"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Currencies",
        }

        return await self.api_client.call_api(
            "/Currencies",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employees(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employees: Annotated[
            Employees,
            Field(
                ...,
                description="Employees with array of Employee object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Employees:  # noqa: E501
        """Creates new employees used in Xero payrun  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employees: Employees with array of Employee object in body of request (required)
        :type employees: Employees
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Employees
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employees_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employees_with_http_info(
            xero_tenant_id, employees, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employees_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employees: Annotated[
            Employees,
            Field(
                ...,
                description="Employees with array of Employee object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates new employees used in Xero payrun  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employees: Employees with array of Employee object in body of request (required)
        :type employees: Employees
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employees",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employees" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employees"] is not None:
            _body_params = _params["employees"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Employees",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Employees",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_expense_claim_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claim_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ExpenseClaim")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific expense claim  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :type expense_claim_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_expense_claim_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_expense_claim_history_with_http_info(
            xero_tenant_id, expense_claim_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_expense_claim_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claim_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ExpenseClaim")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific expense claim  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :type expense_claim_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "expense_claim_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_expense_claim_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["expense_claim_id"] is not None:
            _path_params["ExpenseClaimID"] = _params["expense_claim_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/ExpenseClaims/{ExpenseClaimID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_expense_claims(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claims: Annotated[
            ExpenseClaims,
            Field(
                ...,
                description="ExpenseClaims with array of ExpenseClaim object in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ExpenseClaims:  # noqa: E501
        """Creates expense claims  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claims: ExpenseClaims with array of ExpenseClaim object in body of request (required)
        :type expense_claims: ExpenseClaims
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExpenseClaims
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_expense_claims_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_expense_claims_with_http_info(
            xero_tenant_id, expense_claims, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_expense_claims_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claims: Annotated[
            ExpenseClaims,
            Field(
                ...,
                description="ExpenseClaims with array of ExpenseClaim object in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates expense claims  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claims: ExpenseClaims with array of ExpenseClaim object in body of request (required)
        :type expense_claims: ExpenseClaims
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExpenseClaims, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "expense_claims", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_expense_claims" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["expense_claims"] is not None:
            _body_params = _params["expense_claims"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ExpenseClaims",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ExpenseClaims",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_invoice_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        include_online: Annotated[
            Optional[StrictBool],
            Field(
                description="Allows an attachment to be seen by the end customer within their online invoice"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Creates an attachment for a specific invoice or purchase bill by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param include_online: Allows an attachment to be seen by the end customer within their online invoice
        :type include_online: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_invoice_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_invoice_attachment_by_file_name_with_http_info(
            xero_tenant_id,
            invoice_id,
            file_name,
            body,
            include_online,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_invoice_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        include_online: Annotated[
            Optional[StrictBool],
            Field(
                description="Allows an attachment to be seen by the end customer within their online invoice"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an attachment for a specific invoice or purchase bill by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param include_online: Allows an attachment to be seen by the end customer within their online invoice
        :type include_online: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "invoice_id",
            "file_name",
            "body",
            "include_online",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_invoice_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        if _params.get("include_online") is not None:  # noqa: E501
            _query_params.append(("IncludeOnline", _params["include_online"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_invoice_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_invoice_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_invoice_history_with_http_info(
            xero_tenant_id, invoice_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_invoice_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "invoice_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_invoice_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_invoices(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoices: Annotated[
            Invoices,
            Field(
                ...,
                description="Invoices with an array of invoice objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Invoices:  # noqa: E501
        """Creates one or more sales invoices or purchase bills  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoices: Invoices with an array of invoice objects in body of request (required)
        :type invoices: Invoices
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Invoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_invoices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_invoices_with_http_info(
            xero_tenant_id,
            invoices,
            summarize_errors,
            unitdp,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_invoices_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoices: Annotated[
            Invoices,
            Field(
                ...,
                description="Invoices with an array of invoice objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates one or more sales invoices or purchase bills  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoices: Invoices with an array of invoice objects in body of request (required)
        :type invoices: Invoices
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Invoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "invoices",
            "summarize_errors",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_invoices" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["invoices"] is not None:
            _body_params = _params["invoices"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Invoices",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Invoices",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_item_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_item_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_item_history_with_http_info(
            xero_tenant_id, item_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_item_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "item_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_item_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["item_id"] is not None:
            _path_params["ItemID"] = _params["item_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/Items/{ItemID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_items(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        items: Annotated[
            Items,
            Field(
                ...,
                description="Items with an array of Item objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Items:  # noqa: E501
        """Creates one or more items  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param items: Items with an array of Item objects in body of request (required)
        :type items: Items
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Items
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_items_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_items_with_http_info(
            xero_tenant_id, items, summarize_errors, unitdp, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_items_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        items: Annotated[
            Items,
            Field(
                ...,
                description="Items with an array of Item objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates one or more items  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param items: Items with an array of Item objects in body of request (required)
        :type items: Items
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Items, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "items",
            "summarize_errors",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_items" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["items"] is not None:
            _body_params = _params["items"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Items",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Items",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_linked_transaction(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        linked_transaction: Annotated[
            LinkedTransaction,
            Field(..., description="LinkedTransaction object in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> LinkedTransactions:  # noqa: E501
        """Creates linked transactions (billable expenses)  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param linked_transaction: LinkedTransaction object in body of request (required)
        :type linked_transaction: LinkedTransaction
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LinkedTransactions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_linked_transaction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_linked_transaction_with_http_info(
            xero_tenant_id, linked_transaction, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_linked_transaction_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        linked_transaction: Annotated[
            LinkedTransaction,
            Field(..., description="LinkedTransaction object in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates linked transactions (billable expenses)  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param linked_transaction: LinkedTransaction object in body of request (required)
        :type linked_transaction: LinkedTransaction
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LinkedTransactions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "linked_transaction", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_linked_transaction" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["linked_transaction"] is not None:
            _body_params = _params["linked_transaction"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LinkedTransactions",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/LinkedTransactions",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_manual_journal_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Creates a specific attachment for a specific manual journal by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_manual_journal_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_manual_journal_attachment_by_file_name_with_http_info(
            xero_tenant_id,
            manual_journal_id,
            file_name,
            body,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_manual_journal_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a specific attachment for a specific manual journal by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "manual_journal_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_manual_journal_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["manual_journal_id"] is not None:
            _path_params["ManualJournalID"] = _params["manual_journal_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ManualJournals/{ManualJournalID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_manual_journal_history_record(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_manual_journal_history_record_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_manual_journal_history_record_with_http_info(
            xero_tenant_id,
            manual_journal_id,
            history_records,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_manual_journal_history_record_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "manual_journal_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_manual_journal_history_record" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["manual_journal_id"] is not None:
            _path_params["ManualJournalID"] = _params["manual_journal_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ManualJournals/{ManualJournalID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_manual_journals(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journals: Annotated[
            ManualJournals,
            Field(
                ...,
                description="ManualJournals array with ManualJournal object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ManualJournals:  # noqa: E501
        """Creates one or more manual journals  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journals: ManualJournals array with ManualJournal object in body of request (required)
        :type manual_journals: ManualJournals
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ManualJournals
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_manual_journals_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_manual_journals_with_http_info(
            xero_tenant_id, manual_journals, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_manual_journals_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journals: Annotated[
            ManualJournals,
            Field(
                ...,
                description="ManualJournals array with ManualJournal object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates one or more manual journals  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journals: ManualJournals array with ManualJournal object in body of request (required)
        :type manual_journals: ManualJournals
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ManualJournals, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "manual_journals",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_manual_journals" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["manual_journals"] is not None:
            _body_params = _params["manual_journals"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ManualJournals",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ManualJournals",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_overpayment_allocations(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        allocations: Annotated[
            Allocations,
            Field(
                ...,
                description="Allocations array with Allocation object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Allocations:  # noqa: E501
        """Creates a single allocation for a specific overpayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param allocations: Allocations array with Allocation object in body of request (required)
        :type allocations: Allocations
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Allocations
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_overpayment_allocations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_overpayment_allocations_with_http_info(
            xero_tenant_id,
            overpayment_id,
            allocations,
            summarize_errors,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_overpayment_allocations_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        allocations: Annotated[
            Allocations,
            Field(
                ...,
                description="Allocations array with Allocation object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a single allocation for a specific overpayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param allocations: Allocations array with Allocation object in body of request (required)
        :type allocations: Allocations
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Allocations, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "overpayment_id",
            "allocations",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_overpayment_allocations" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["overpayment_id"] is not None:
            _path_params["OverpaymentID"] = _params["overpayment_id"]

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["allocations"] is not None:
            _body_params = _params["allocations"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Allocations",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Overpayments/{OverpaymentID}/Allocations",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_overpayment_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific overpayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_overpayment_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_overpayment_history_with_http_info(
            xero_tenant_id, overpayment_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_overpayment_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific overpayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "overpayment_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_overpayment_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["overpayment_id"] is not None:
            _path_params["OverpaymentID"] = _params["overpayment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Overpayments/{OverpaymentID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_payment(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment: Annotated[
            Payment, Field(..., description="Request body with a single Payment object")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Payments:  # noqa: E501
        """Creates a single payment for invoice or credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment: Request body with a single Payment object (required)
        :type payment: Payment
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Payments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_payment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_payment_with_http_info(
            xero_tenant_id, payment, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_payment_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment: Annotated[
            Payment, Field(..., description="Request body with a single Payment object")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a single payment for invoice or credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment: Request body with a single Payment object (required)
        :type payment: Payment
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Payments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "payment", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_payment" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["payment"] is not None:
            _body_params = _params["payment"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Payments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Payments",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_payment_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Payment")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific payment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_id: Unique identifier for a Payment (required)
        :type payment_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_payment_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_payment_history_with_http_info(
            xero_tenant_id, payment_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_payment_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Payment")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific payment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_id: Unique identifier for a Payment (required)
        :type payment_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "payment_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_payment_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["payment_id"] is not None:
            _path_params["PaymentID"] = _params["payment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Payments/{PaymentID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_payment_service(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_services: Annotated[
            PaymentServices,
            Field(
                ...,
                description="PaymentServices array with PaymentService object in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PaymentServices:  # noqa: E501
        """Creates a payment service  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_services: PaymentServices array with PaymentService object in body of request (required)
        :type payment_services: PaymentServices
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaymentServices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_payment_service_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_payment_service_with_http_info(
            xero_tenant_id, payment_services, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_payment_service_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_services: Annotated[
            PaymentServices,
            Field(
                ...,
                description="PaymentServices array with PaymentService object in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a payment service  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_services: PaymentServices array with PaymentService object in body of request (required)
        :type payment_services: PaymentServices
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaymentServices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "payment_services", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_payment_service" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["payment_services"] is not None:
            _body_params = _params["payment_services"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PaymentServices",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/PaymentServices",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_payments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payments: Annotated[
            Payments,
            Field(
                ..., description="Payments array with Payment object in body of request"
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Payments:  # noqa: E501
        """Creates multiple payments for invoices or credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payments: Payments array with Payment object in body of request (required)
        :type payments: Payments
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Payments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_payments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_payments_with_http_info(
            xero_tenant_id, payments, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_payments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payments: Annotated[
            Payments,
            Field(
                ..., description="Payments array with Payment object in body of request"
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates multiple payments for invoices or credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payments: Payments array with Payment object in body of request (required)
        :type payments: Payments
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Payments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "payments",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_payments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["payments"] is not None:
            _body_params = _params["payments"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Payments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Payments",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_prepayment_allocations(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        allocations: Annotated[
            Allocations,
            Field(
                ...,
                description="Allocations with an array of Allocation object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Allocations:  # noqa: E501
        """Allows you to create an Allocation for prepayments  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param allocations: Allocations with an array of Allocation object in body of request (required)
        :type allocations: Allocations
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Allocations
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_prepayment_allocations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_prepayment_allocations_with_http_info(
            xero_tenant_id,
            prepayment_id,
            allocations,
            summarize_errors,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_prepayment_allocations_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        allocations: Annotated[
            Allocations,
            Field(
                ...,
                description="Allocations with an array of Allocation object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Allows you to create an Allocation for prepayments  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param allocations: Allocations with an array of Allocation object in body of request (required)
        :type allocations: Allocations
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Allocations, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "prepayment_id",
            "allocations",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_prepayment_allocations" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["prepayment_id"] is not None:
            _path_params["PrepaymentID"] = _params["prepayment_id"]

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["allocations"] is not None:
            _body_params = _params["allocations"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Allocations",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Prepayments/{PrepaymentID}/Allocations",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_prepayment_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific prepayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_prepayment_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_prepayment_history_with_http_info(
            xero_tenant_id, prepayment_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_prepayment_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific prepayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "prepayment_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_prepayment_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["prepayment_id"] is not None:
            _path_params["PrepaymentID"] = _params["prepayment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Prepayments/{PrepaymentID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_purchase_order_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Creates attachment for a specific purchase order  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_purchase_order_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_purchase_order_attachment_by_file_name_with_http_info(
            xero_tenant_id,
            purchase_order_id,
            file_name,
            body,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_purchase_order_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates attachment for a specific purchase order  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "purchase_order_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_purchase_order_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_purchase_order_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific purchase orders  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_purchase_order_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_purchase_order_history_with_http_info(
            xero_tenant_id,
            purchase_order_id,
            history_records,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_purchase_order_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific purchase orders  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "purchase_order_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_purchase_order_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_purchase_orders(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_orders: Annotated[
            PurchaseOrders,
            Field(
                ...,
                description="PurchaseOrders with an array of PurchaseOrder object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PurchaseOrders:  # noqa: E501
        """Creates one or more purchase orders  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_orders: PurchaseOrders with an array of PurchaseOrder object in body of request (required)
        :type purchase_orders: PurchaseOrders
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PurchaseOrders
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_purchase_orders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_purchase_orders_with_http_info(
            xero_tenant_id, purchase_orders, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_purchase_orders_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_orders: Annotated[
            PurchaseOrders,
            Field(
                ...,
                description="PurchaseOrders with an array of PurchaseOrder object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates one or more purchase orders  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_orders: PurchaseOrders with an array of PurchaseOrder object in body of request (required)
        :type purchase_orders: PurchaseOrders
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "purchase_orders",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_purchase_orders" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["purchase_orders"] is not None:
            _body_params = _params["purchase_orders"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PurchaseOrders",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_quote_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Creates attachment for a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_quote_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_quote_attachment_by_file_name_with_http_info(
            xero_tenant_id, quote_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_quote_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates attachment for a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "quote_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_quote_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_quote_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_quote_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_quote_history_with_http_info(
            xero_tenant_id, quote_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_quote_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "quote_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_quote_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_quotes(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quotes: Annotated[
            Quotes,
            Field(
                ...,
                description="Quotes with an array of Quote object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Quotes:  # noqa: E501
        """Create one or more quotes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quotes: Quotes with an array of Quote object in body of request (required)
        :type quotes: Quotes
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Quotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_quotes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_quotes_with_http_info(
            xero_tenant_id, quotes, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_quotes_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quotes: Annotated[
            Quotes,
            Field(
                ...,
                description="Quotes with an array of Quote object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Create one or more quotes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quotes: Quotes with an array of Quote object in body of request (required)
        :type quotes: Quotes
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Quotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "quotes",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_quotes" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["quotes"] is not None:
            _body_params = _params["quotes"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Quotes",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Quotes",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_receipt(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipts: Annotated[
            Receipts,
            Field(
                ...,
                description="Receipts with an array of Receipt object in body of request",
            ),
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Receipts:  # noqa: E501
        """Creates draft expense claim receipts for any user  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipts: Receipts with an array of Receipt object in body of request (required)
        :type receipts: Receipts
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Receipts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_receipt_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_receipt_with_http_info(
            xero_tenant_id, receipts, unitdp, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_receipt_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipts: Annotated[
            Receipts,
            Field(
                ...,
                description="Receipts with an array of Receipt object in body of request",
            ),
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates draft expense claim receipts for any user  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipts: Receipts with an array of Receipt object in body of request (required)
        :type receipts: Receipts
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Receipts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "receipts", "unitdp", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_receipt" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["receipts"] is not None:
            _body_params = _params["receipts"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Receipts",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Receipts",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_receipt_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Creates an attachment on a specific expense claim receipts by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_receipt_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_receipt_attachment_by_file_name_with_http_info(
            xero_tenant_id, receipt_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_receipt_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an attachment on a specific expense claim receipts by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "receipt_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_receipt_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["receipt_id"] is not None:
            _path_params["ReceiptID"] = _params["receipt_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Receipts/{ReceiptID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_receipt_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a history record for a specific receipt  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_receipt_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_receipt_history_with_http_info(
            xero_tenant_id, receipt_id, history_records, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_receipt_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a history record for a specific receipt  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "receipt_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_receipt_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["receipt_id"] is not None:
            _path_params["ReceiptID"] = _params["receipt_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Receipts/{ReceiptID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_repeating_invoice_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Creates an attachment from a specific repeating invoices by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_repeating_invoice_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return (
            await self.create_repeating_invoice_attachment_by_file_name_with_http_info(
                xero_tenant_id,
                repeating_invoice_id,
                file_name,
                body,
                idempotency_key,
                **kwargs,
            )
        )  # noqa: E501

    async def create_repeating_invoice_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an attachment from a specific repeating invoices by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "repeating_invoice_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repeating_invoice_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["repeating_invoice_id"] is not None:
            _path_params["RepeatingInvoiceID"] = _params["repeating_invoice_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_repeating_invoice_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Creates a  history record for a specific repeating invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_repeating_invoice_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_repeating_invoice_history_with_http_info(
            xero_tenant_id,
            repeating_invoice_id,
            history_records,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_repeating_invoice_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        history_records: Annotated[
            HistoryRecords,
            Field(
                ...,
                description="HistoryRecords containing an array of HistoryRecord objects in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a  history record for a specific repeating invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param history_records: HistoryRecords containing an array of HistoryRecord objects in body of request (required)
        :type history_records: HistoryRecords
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "repeating_invoice_id",
            "history_records",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repeating_invoice_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["repeating_invoice_id"] is not None:
            _path_params["RepeatingInvoiceID"] = _params["repeating_invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["history_records"] is not None:
            _body_params = _params["history_records"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices/{RepeatingInvoiceID}/History",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_repeating_invoices(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoices: Annotated[
            RepeatingInvoices,
            Field(
                ...,
                description="RepeatingInvoices with an array of repeating invoice objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> RepeatingInvoices:  # noqa: E501
        """Creates one or more repeating invoice templates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoices: RepeatingInvoices with an array of repeating invoice objects in body of request (required)
        :type repeating_invoices: RepeatingInvoices
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RepeatingInvoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_repeating_invoices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_repeating_invoices_with_http_info(
            xero_tenant_id,
            repeating_invoices,
            summarize_errors,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_repeating_invoices_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoices: Annotated[
            RepeatingInvoices,
            Field(
                ...,
                description="RepeatingInvoices with an array of repeating invoice objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates one or more repeating invoice templates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoices: RepeatingInvoices with an array of repeating invoice objects in body of request (required)
        :type repeating_invoices: RepeatingInvoices
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RepeatingInvoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "repeating_invoices",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repeating_invoices" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["repeating_invoices"] is not None:
            _body_params = _params["repeating_invoices"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "RepeatingInvoices",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_tax_rates(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tax_rates: Annotated[
            TaxRates,
            Field(
                ..., description="TaxRates array with TaxRate object in body of request"
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TaxRates:  # noqa: E501
        """Creates one or more tax rates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tax_rates: TaxRates array with TaxRate object in body of request (required)
        :type tax_rates: TaxRates
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TaxRates
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_tax_rates_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_tax_rates_with_http_info(
            xero_tenant_id, tax_rates, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_tax_rates_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tax_rates: Annotated[
            TaxRates,
            Field(
                ..., description="TaxRates array with TaxRate object in body of request"
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates one or more tax rates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tax_rates: TaxRates array with TaxRate object in body of request (required)
        :type tax_rates: TaxRates
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TaxRates, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "tax_rates", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tax_rates" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["tax_rates"] is not None:
            _body_params = _params["tax_rates"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TaxRates",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/TaxRates",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_tracking_category(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category: Annotated[
            TrackingCategory,
            Field(..., description="TrackingCategory object in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TrackingCategories:  # noqa: E501
        """Create tracking categories  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category: TrackingCategory object in body of request (required)
        :type tracking_category: TrackingCategory
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingCategories
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_tracking_category_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_tracking_category_with_http_info(
            xero_tenant_id, tracking_category, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_tracking_category_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category: Annotated[
            TrackingCategory,
            Field(..., description="TrackingCategory object in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Create tracking categories  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category: TrackingCategory object in body of request (required)
        :type tracking_category: TrackingCategory
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "tracking_category", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tracking_category" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["tracking_category"] is not None:
            _body_params = _params["tracking_category"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TrackingCategories",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/TrackingCategories",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_tracking_options(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        tracking_option: Annotated[
            TrackingOption,
            Field(..., description="TrackingOption object in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TrackingOptions:  # noqa: E501
        """Creates options for a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param tracking_option: TrackingOption object in body of request (required)
        :type tracking_option: TrackingOption
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingOptions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_tracking_options_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_tracking_options_with_http_info(
            xero_tenant_id,
            tracking_category_id,
            tracking_option,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_tracking_options_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        tracking_option: Annotated[
            TrackingOption,
            Field(..., description="TrackingOption object in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates options for a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param tracking_option: TrackingOption object in body of request (required)
        :type tracking_option: TrackingOption
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingOptions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "tracking_category_id",
            "tracking_option",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tracking_options" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["tracking_category_id"] is not None:
            _path_params["TrackingCategoryID"] = _params["tracking_category_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["tracking_option"] is not None:
            _body_params = _params["tracking_option"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TrackingOptions",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/TrackingCategories/{TrackingCategoryID}/Options",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_account(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        **kwargs,
    ) -> Accounts:  # noqa: E501
        """Deletes a chart of accounts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Accounts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_account_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_account_with_http_info(
            xero_tenant_id, account_id, **kwargs
        )  # noqa: E501

    async def delete_account_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a chart of accounts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "account_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_account" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["AccountID"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Accounts",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Accounts/{AccountID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_batch_payment(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_delete: BatchPaymentDelete,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> BatchPayments:  # noqa: E501
        """Updates a specific batch payment for invoices and credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_delete: (required)
        :type batch_payment_delete: BatchPaymentDelete
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BatchPayments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_batch_payment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_batch_payment_with_http_info(
            xero_tenant_id, batch_payment_delete, idempotency_key, **kwargs
        )  # noqa: E501

    async def delete_batch_payment_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_delete: BatchPaymentDelete,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific batch payment for invoices and credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_delete: (required)
        :type batch_payment_delete: BatchPaymentDelete
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BatchPayments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "batch_payment_delete", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_batch_payment" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["batch_payment_delete"] is not None:
            _body_params = _params["batch_payment_delete"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BatchPayments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BatchPayments",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_batch_payment_by_url_param(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for BatchPayment")
        ],
        batch_payment_delete_by_url_param: BatchPaymentDeleteByUrlParam,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> BatchPayments:  # noqa: E501
        """Updates a specific batch payment for invoices and credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_id: Unique identifier for BatchPayment (required)
        :type batch_payment_id: str
        :param batch_payment_delete_by_url_param: (required)
        :type batch_payment_delete_by_url_param: BatchPaymentDeleteByUrlParam
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BatchPayments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_batch_payment_by_url_param_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_batch_payment_by_url_param_with_http_info(
            xero_tenant_id,
            batch_payment_id,
            batch_payment_delete_by_url_param,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def delete_batch_payment_by_url_param_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for BatchPayment")
        ],
        batch_payment_delete_by_url_param: BatchPaymentDeleteByUrlParam,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific batch payment for invoices and credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_id: Unique identifier for BatchPayment (required)
        :type batch_payment_id: str
        :param batch_payment_delete_by_url_param: (required)
        :type batch_payment_delete_by_url_param: BatchPaymentDeleteByUrlParam
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BatchPayments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "batch_payment_id",
            "batch_payment_delete_by_url_param",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_batch_payment_by_url_param" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["batch_payment_id"] is not None:
            _path_params["BatchPaymentID"] = _params["batch_payment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["batch_payment_delete_by_url_param"] is not None:
            _body_params = _params["batch_payment_delete_by_url_param"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BatchPayments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BatchPayments/{BatchPaymentID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_contact_group_contact(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> None:  # noqa: E501
        """Deletes a specific contact from a contact group using a unique contact Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_contact_group_contact_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_contact_group_contact_with_http_info(
            xero_tenant_id, contact_group_id, contact_id, **kwargs
        )  # noqa: E501

    async def delete_contact_group_contact_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a specific contact from a contact group using a unique contact Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_group_id", "contact_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contact_group_contact" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_group_id"] is not None:
            _path_params["ContactGroupID"] = _params["contact_group_id"]

        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            "/ContactGroups/{ContactGroupID}/Contacts/{ContactID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_contact_group_contacts(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        **kwargs,
    ) -> None:  # noqa: E501
        """Deletes all contacts from a specific contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_contact_group_contacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_contact_group_contacts_with_http_info(
            xero_tenant_id, contact_group_id, **kwargs
        )  # noqa: E501

    async def delete_contact_group_contacts_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes all contacts from a specific contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_group_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contact_group_contacts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_group_id"] is not None:
            _path_params["ContactGroupID"] = _params["contact_group_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            "/ContactGroups/{ContactGroupID}/Contacts",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_credit_note_allocations(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        allocation_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Allocation object")
        ],
        **kwargs,
    ) -> Allocation:  # noqa: E501
        """Deletes an Allocation from a Credit Note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param allocation_id: Unique identifier for Allocation object (required)
        :type allocation_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Allocation
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_credit_note_allocations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_credit_note_allocations_with_http_info(
            xero_tenant_id, credit_note_id, allocation_id, **kwargs
        )  # noqa: E501

    async def delete_credit_note_allocations_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        allocation_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Allocation object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes an Allocation from a Credit Note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param allocation_id: Unique identifier for Allocation object (required)
        :type allocation_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Allocation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "credit_note_id", "allocation_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_credit_note_allocations" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        if _params["allocation_id"] is not None:
            _path_params["AllocationID"] = _params["allocation_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Allocation",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/Allocations/{AllocationID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_item(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        **kwargs,
    ) -> None:  # noqa: E501
        """Deletes a specific item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_item_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_item_with_http_info(xero_tenant_id, item_id, **kwargs)  # noqa: E501

    async def delete_item_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a specific item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "item_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_item" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["item_id"] is not None:
            _path_params["ItemID"] = _params["item_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            "/Items/{ItemID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_linked_transaction(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        linked_transaction_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a LinkedTransaction"),
        ],
        **kwargs,
    ) -> None:  # noqa: E501
        """Deletes a specific linked transactions (billable expenses)  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :type linked_transaction_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_linked_transaction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_linked_transaction_with_http_info(
            xero_tenant_id, linked_transaction_id, **kwargs
        )  # noqa: E501

    async def delete_linked_transaction_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        linked_transaction_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a LinkedTransaction"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a specific linked transactions (billable expenses)  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :type linked_transaction_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "linked_transaction_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_linked_transaction" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["linked_transaction_id"] is not None:
            _path_params["LinkedTransactionID"] = _params["linked_transaction_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            "/LinkedTransactions/{LinkedTransactionID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_overpayment_allocations(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        allocation_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Allocation object")
        ],
        **kwargs,
    ) -> Allocation:  # noqa: E501
        """Deletes an Allocation from an overpayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param allocation_id: Unique identifier for Allocation object (required)
        :type allocation_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Allocation
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_overpayment_allocations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_overpayment_allocations_with_http_info(
            xero_tenant_id, overpayment_id, allocation_id, **kwargs
        )  # noqa: E501

    async def delete_overpayment_allocations_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        allocation_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Allocation object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes an Allocation from an overpayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param allocation_id: Unique identifier for Allocation object (required)
        :type allocation_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Allocation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "overpayment_id", "allocation_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_overpayment_allocations" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["overpayment_id"] is not None:
            _path_params["OverpaymentID"] = _params["overpayment_id"]

        if _params["allocation_id"] is not None:
            _path_params["AllocationID"] = _params["allocation_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Allocation",
        }

        return await self.api_client.call_api(
            "/Overpayments/{OverpaymentID}/Allocations/{AllocationID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_payment(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Payment")
        ],
        payment_delete: PaymentDelete,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Payments:  # noqa: E501
        """Updates a specific payment for invoices and credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_id: Unique identifier for a Payment (required)
        :type payment_id: str
        :param payment_delete: (required)
        :type payment_delete: PaymentDelete
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Payments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_payment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_payment_with_http_info(
            xero_tenant_id, payment_id, payment_delete, idempotency_key, **kwargs
        )  # noqa: E501

    async def delete_payment_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Payment")
        ],
        payment_delete: PaymentDelete,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific payment for invoices and credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_id: Unique identifier for a Payment (required)
        :type payment_id: str
        :param payment_delete: (required)
        :type payment_delete: PaymentDelete
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Payments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "payment_id",
            "payment_delete",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_payment" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["payment_id"] is not None:
            _path_params["PaymentID"] = _params["payment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["payment_delete"] is not None:
            _body_params = _params["payment_delete"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Payments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Payments/{PaymentID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_prepayment_allocations(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        allocation_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Allocation object")
        ],
        **kwargs,
    ) -> Allocation:  # noqa: E501
        """Deletes an Allocation from a Prepayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param allocation_id: Unique identifier for Allocation object (required)
        :type allocation_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Allocation
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_prepayment_allocations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_prepayment_allocations_with_http_info(
            xero_tenant_id, prepayment_id, allocation_id, **kwargs
        )  # noqa: E501

    async def delete_prepayment_allocations_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        allocation_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Allocation object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes an Allocation from a Prepayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param allocation_id: Unique identifier for Allocation object (required)
        :type allocation_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Allocation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "prepayment_id", "allocation_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_prepayment_allocations" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["prepayment_id"] is not None:
            _path_params["PrepaymentID"] = _params["prepayment_id"]

        if _params["allocation_id"] is not None:
            _path_params["AllocationID"] = _params["allocation_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Allocation",
        }

        return await self.api_client.call_api(
            "/Prepayments/{PrepaymentID}/Allocations/{AllocationID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_tracking_category(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        **kwargs,
    ) -> TrackingCategories:  # noqa: E501
        """Deletes a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingCategories
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_tracking_category_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_tracking_category_with_http_info(
            xero_tenant_id, tracking_category_id, **kwargs
        )  # noqa: E501

    async def delete_tracking_category_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "tracking_category_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tracking_category" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["tracking_category_id"] is not None:
            _path_params["TrackingCategoryID"] = _params["tracking_category_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TrackingCategories",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/TrackingCategories/{TrackingCategoryID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_tracking_options(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        tracking_option_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Tracking Option")
        ],
        **kwargs,
    ) -> TrackingOptions:  # noqa: E501
        """Deletes a specific option for a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param tracking_option_id: Unique identifier for a Tracking Option (required)
        :type tracking_option_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingOptions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_tracking_options_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_tracking_options_with_http_info(
            xero_tenant_id, tracking_category_id, tracking_option_id, **kwargs
        )  # noqa: E501

    async def delete_tracking_options_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        tracking_option_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Tracking Option")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a specific option for a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param tracking_option_id: Unique identifier for a Tracking Option (required)
        :type tracking_option_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingOptions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "tracking_category_id", "tracking_option_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tracking_options" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["tracking_category_id"] is not None:
            _path_params["TrackingCategoryID"] = _params["tracking_category_id"]

        if _params["tracking_option_id"] is not None:
            _path_params["TrackingOptionID"] = _params["tracking_option_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TrackingOptions",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def email_invoice(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        request_empty: RequestEmpty,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> None:  # noqa: E501
        """Sends a copy of a specific invoice to related contact via email  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param request_empty: (required)
        :type request_empty: RequestEmpty
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the email_invoice_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.email_invoice_with_http_info(
            xero_tenant_id, invoice_id, request_empty, idempotency_key, **kwargs
        )  # noqa: E501

    async def email_invoice_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        request_empty: RequestEmpty,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Sends a copy of a specific invoice to related contact via email  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param request_empty: (required)
        :type request_empty: RequestEmpty
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "invoice_id",
            "request_empty",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method email_invoice" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["request_empty"] is not None:
            _body_params = _params["request_empty"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {}

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/Email",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_account(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        **kwargs,
    ) -> Accounts:  # noqa: E501
        """Retrieves a single chart of accounts by using a unique account Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Accounts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_account_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_account_with_http_info(
            xero_tenant_id, account_id, **kwargs
        )  # noqa: E501

    async def get_account_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a single chart of accounts by using a unique account Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "account_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["AccountID"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Accounts",
        }

        return await self.api_client.call_api(
            "/Accounts/{AccountID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_account_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves an attachment for a specific account by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_account_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_account_attachment_by_file_name_with_http_info(
            xero_tenant_id, account_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_account_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves an attachment for a specific account by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "account_id", "file_name", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["AccountID"] = _params["account_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Accounts/{AccountID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_account_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific account using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_account_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_account_attachment_by_id_with_http_info(
            xero_tenant_id, account_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_account_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific account using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "account_id", "attachment_id", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["AccountID"] = _params["account_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Accounts/{AccountID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_account_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachments for a specific accounts by using a unique account Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_account_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_account_attachments_with_http_info(
            xero_tenant_id, account_id, **kwargs
        )  # noqa: E501

    async def get_account_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachments for a specific accounts by using a unique account Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "account_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["AccountID"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/Accounts/{AccountID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_accounts(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> Accounts:  # noqa: E501
        """Retrieves the full chart of accounts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Accounts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_accounts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_accounts_with_http_info(
            xero_tenant_id, if_modified_since, where, order, **kwargs
        )  # noqa: E501

    async def get_accounts_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves the full chart of accounts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_accounts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Accounts",
        }

        return await self.api_client.call_api(
            "/Accounts",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transaction(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> BankTransactions:  # noqa: E501
        """Retrieves a single spent or received money transaction by using a unique bank transaction Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BankTransactions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transaction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transaction_with_http_info(
            xero_tenant_id, bank_transaction_id, unitdp, **kwargs
        )  # noqa: E501

    async def get_bank_transaction_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a single spent or received money transaction by using a unique bank transaction Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BankTransactions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "bank_transaction_id", "unitdp"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transaction" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transaction_id"] is not None:
            _path_params["BankTransactionID"] = _params["bank_transaction_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BankTransactions",
        }

        return await self.api_client.call_api(
            "/BankTransactions/{BankTransactionID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transaction_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific bank transaction by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transaction_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transaction_attachment_by_file_name_with_http_info(
            xero_tenant_id, bank_transaction_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_bank_transaction_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific bank transaction by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transaction_id",
            "file_name",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transaction_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transaction_id"] is not None:
            _path_params["BankTransactionID"] = _params["bank_transaction_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/BankTransactions/{BankTransactionID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transaction_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves specific attachments from a specific BankTransaction using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transaction_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transaction_attachment_by_id_with_http_info(
            xero_tenant_id, bank_transaction_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_bank_transaction_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves specific attachments from a specific BankTransaction using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transaction_id",
            "attachment_id",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transaction_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transaction_id"] is not None:
            _path_params["BankTransactionID"] = _params["bank_transaction_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/BankTransactions/{BankTransactionID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transaction_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves any attachments from a specific bank transactions  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transaction_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transaction_attachments_with_http_info(
            xero_tenant_id, bank_transaction_id, **kwargs
        )  # noqa: E501

    async def get_bank_transaction_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves any attachments from a specific bank transactions  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "bank_transaction_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transaction_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transaction_id"] is not None:
            _path_params["BankTransactionID"] = _params["bank_transaction_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/BankTransactions/{BankTransactionID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transactions(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Up to 100 bank transactions will be returned in a single API call with line items details"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> BankTransactions:  # noqa: E501
        """Retrieves any spent or received money transactions  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: Up to 100 bank transactions will be returned in a single API call with line items details
        :type page: int
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BankTransactions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transactions_with_http_info(
            xero_tenant_id,
            if_modified_since,
            where,
            order,
            page,
            unitdp,
            page_size,
            **kwargs,
        )  # noqa: E501

    async def get_bank_transactions_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Up to 100 bank transactions will be returned in a single API call with line items details"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves any spent or received money transactions  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: Up to 100 bank transactions will be returned in a single API call with line items details
        :type page: int
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BankTransactions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "page",
            "unitdp",
            "page_size",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transactions" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        if _params.get("page_size") is not None:  # noqa: E501
            _query_params.append(("pageSize", _params["page_size"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BankTransactions",
        }

        return await self.api_client.call_api(
            "/BankTransactions",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transactions_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history from a specific bank transaction using a unique bank transaction Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transactions_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transactions_history_with_http_info(
            xero_tenant_id, bank_transaction_id, **kwargs
        )  # noqa: E501

    async def get_bank_transactions_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history from a specific bank transaction using a unique bank transaction Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "bank_transaction_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transactions_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transaction_id"] is not None:
            _path_params["BankTransactionID"] = _params["bank_transaction_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/BankTransactions/{BankTransactionID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transfer(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        **kwargs,
    ) -> BankTransfers:  # noqa: E501
        """Retrieves specific bank transfers by using a unique bank transfer Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BankTransfers
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transfer_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transfer_with_http_info(
            xero_tenant_id, bank_transfer_id, **kwargs
        )  # noqa: E501

    async def get_bank_transfer_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves specific bank transfers by using a unique bank transfer Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BankTransfers, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "bank_transfer_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transfer_id"] is not None:
            _path_params["BankTransferID"] = _params["bank_transfer_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BankTransfers",
        }

        return await self.api_client.call_api(
            "/BankTransfers/{BankTransferID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transfer_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment on a specific bank transfer by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transfer_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transfer_attachment_by_file_name_with_http_info(
            xero_tenant_id, bank_transfer_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_bank_transfer_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment on a specific bank transfer by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transfer_id",
            "file_name",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transfer_id"] is not None:
            _path_params["BankTransferID"] = _params["bank_transfer_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/BankTransfers/{BankTransferID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transfer_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific bank transfer using a unique attachment ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transfer_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transfer_attachment_by_id_with_http_info(
            xero_tenant_id, bank_transfer_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_bank_transfer_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific bank transfer using a unique attachment ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transfer_id",
            "attachment_id",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transfer_id"] is not None:
            _path_params["BankTransferID"] = _params["bank_transfer_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/BankTransfers/{BankTransferID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transfer_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachments from a specific bank transfer  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transfer_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transfer_attachments_with_http_info(
            xero_tenant_id, bank_transfer_id, **kwargs
        )  # noqa: E501

    async def get_bank_transfer_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachments from a specific bank transfer  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "bank_transfer_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transfer_id"] is not None:
            _path_params["BankTransferID"] = _params["bank_transfer_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/BankTransfers/{BankTransferID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transfer_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history from a specific bank transfer using a unique bank transfer Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transfer_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transfer_history_with_http_info(
            xero_tenant_id, bank_transfer_id, **kwargs
        )  # noqa: E501

    async def get_bank_transfer_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history from a specific bank transfer using a unique bank transfer Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "bank_transfer_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transfer_id"] is not None:
            _path_params["BankTransferID"] = _params["bank_transfer_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/BankTransfers/{BankTransferID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_bank_transfers(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> BankTransfers:  # noqa: E501
        """Retrieves all bank transfers  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BankTransfers
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_bank_transfers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_bank_transfers_with_http_info(
            xero_tenant_id, if_modified_since, where, order, **kwargs
        )  # noqa: E501

    async def get_bank_transfers_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves all bank transfers  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BankTransfers, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfers" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BankTransfers",
        }

        return await self.api_client.call_api(
            "/BankTransfers",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_batch_payment(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for BatchPayment")
        ],
        **kwargs,
    ) -> BatchPayments:  # noqa: E501
        """Retrieves a specific batch payment using a unique batch payment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_id: Unique identifier for BatchPayment (required)
        :type batch_payment_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BatchPayments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_batch_payment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_batch_payment_with_http_info(
            xero_tenant_id, batch_payment_id, **kwargs
        )  # noqa: E501

    async def get_batch_payment_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for BatchPayment")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific batch payment using a unique batch payment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_id: Unique identifier for BatchPayment (required)
        :type batch_payment_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BatchPayments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "batch_payment_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_batch_payment" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["batch_payment_id"] is not None:
            _path_params["BatchPaymentID"] = _params["batch_payment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BatchPayments",
        }

        return await self.api_client.call_api(
            "/BatchPayments/{BatchPaymentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_batch_payment_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for BatchPayment")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history from a specific batch payment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_id: Unique identifier for BatchPayment (required)
        :type batch_payment_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_batch_payment_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_batch_payment_history_with_http_info(
            xero_tenant_id, batch_payment_id, **kwargs
        )  # noqa: E501

    async def get_batch_payment_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        batch_payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for BatchPayment")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history from a specific batch payment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param batch_payment_id: Unique identifier for BatchPayment (required)
        :type batch_payment_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "batch_payment_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_batch_payment_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["batch_payment_id"] is not None:
            _path_params["BatchPaymentID"] = _params["batch_payment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/BatchPayments/{BatchPaymentID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_batch_payments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> BatchPayments:  # noqa: E501
        """Retrieves either one or many batch payments for invoices  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BatchPayments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_batch_payments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_batch_payments_with_http_info(
            xero_tenant_id, if_modified_since, where, order, **kwargs
        )  # noqa: E501

    async def get_batch_payments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves either one or many batch payments for invoices  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BatchPayments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_batch_payments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BatchPayments",
        }

        return await self.api_client.call_api(
            "/BatchPayments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_branding_theme(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        branding_theme_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Branding Theme")
        ],
        **kwargs,
    ) -> BrandingThemes:  # noqa: E501
        """Retrieves a specific branding theme using a unique branding theme Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param branding_theme_id: Unique identifier for a Branding Theme (required)
        :type branding_theme_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BrandingThemes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_branding_theme_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_branding_theme_with_http_info(
            xero_tenant_id, branding_theme_id, **kwargs
        )  # noqa: E501

    async def get_branding_theme_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        branding_theme_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Branding Theme")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific branding theme using a unique branding theme Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param branding_theme_id: Unique identifier for a Branding Theme (required)
        :type branding_theme_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BrandingThemes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "branding_theme_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branding_theme" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["branding_theme_id"] is not None:
            _path_params["BrandingThemeID"] = _params["branding_theme_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BrandingThemes",
        }

        return await self.api_client.call_api(
            "/BrandingThemes/{BrandingThemeID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_branding_theme_payment_services(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        branding_theme_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Branding Theme")
        ],
        **kwargs,
    ) -> PaymentServices:  # noqa: E501
        """Retrieves the payment services for a specific branding theme  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param branding_theme_id: Unique identifier for a Branding Theme (required)
        :type branding_theme_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaymentServices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_branding_theme_payment_services_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_branding_theme_payment_services_with_http_info(
            xero_tenant_id, branding_theme_id, **kwargs
        )  # noqa: E501

    async def get_branding_theme_payment_services_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        branding_theme_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Branding Theme")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves the payment services for a specific branding theme  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param branding_theme_id: Unique identifier for a Branding Theme (required)
        :type branding_theme_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaymentServices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "branding_theme_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branding_theme_payment_services" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["branding_theme_id"] is not None:
            _path_params["BrandingThemeID"] = _params["branding_theme_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PaymentServices",
        }

        return await self.api_client.call_api(
            "/BrandingThemes/{BrandingThemeID}/PaymentServices",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_branding_themes(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> BrandingThemes:  # noqa: E501
        """Retrieves all the branding themes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BrandingThemes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_branding_themes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_branding_themes_with_http_info(xero_tenant_id, **kwargs)  # noqa: E501

    async def get_branding_themes_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves all the branding themes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BrandingThemes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branding_themes" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BrandingThemes",
        }

        return await self.api_client.call_api(
            "/BrandingThemes",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_budget(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        budget_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Budgets")
        ],
        date_to: Annotated[
            Optional[date], Field(description="Filter by start date")
        ] = None,
        date_from: Annotated[
            Optional[date], Field(description="Filter by end date")
        ] = None,
        **kwargs,
    ) -> Budgets:  # noqa: E501
        """Retrieves a specific budget, which includes budget lines  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param budget_id: Unique identifier for Budgets (required)
        :type budget_id: str
        :param date_to: Filter by start date
        :type date_to: date
        :param date_from: Filter by end date
        :type date_from: date
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Budgets
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_budget_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_budget_with_http_info(
            xero_tenant_id, budget_id, date_to, date_from, **kwargs
        )  # noqa: E501

    async def get_budget_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        budget_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Budgets")
        ],
        date_to: Annotated[
            Optional[date], Field(description="Filter by start date")
        ] = None,
        date_from: Annotated[
            Optional[date], Field(description="Filter by end date")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific budget, which includes budget lines  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param budget_id: Unique identifier for Budgets (required)
        :type budget_id: str
        :param date_to: Filter by start date
        :type date_to: date
        :param date_from: Filter by end date
        :type date_from: date
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Budgets, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "budget_id", "date_to", "date_from"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_budget" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["budget_id"] is not None:
            _path_params["BudgetID"] = _params["budget_id"]

        # process the query parameters
        _query_params = []
        if _params.get("date_to") is not None:  # noqa: E501
            if isinstance(_params["date_to"], date):
                _query_params.append(
                    (
                        "DateTo",
                        _params["date_to"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("DateTo", _params["date_to"]))

        if _params.get("date_from") is not None:  # noqa: E501
            if isinstance(_params["date_from"], date):
                _query_params.append(
                    (
                        "DateFrom",
                        _params["date_from"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("DateFrom", _params["date_from"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Budgets",
        }

        return await self.api_client.call_api(
            "/Budgets/{BudgetID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_budgets(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        ids: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="Filter by BudgetID. Allows you to retrieve a specific individual budget."
            ),
        ] = None,
        date_to: Annotated[
            Optional[date], Field(description="Filter by start date")
        ] = None,
        date_from: Annotated[
            Optional[date], Field(description="Filter by end date")
        ] = None,
        **kwargs,
    ) -> Budgets:  # noqa: E501
        """Retrieve a list of budgets  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param ids: Filter by BudgetID. Allows you to retrieve a specific individual budget.
        :type ids: list[str]
        :param date_to: Filter by start date
        :type date_to: date
        :param date_from: Filter by end date
        :type date_from: date
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Budgets
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_budgets_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_budgets_with_http_info(
            xero_tenant_id, ids, date_to, date_from, **kwargs
        )  # noqa: E501

    async def get_budgets_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        ids: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="Filter by BudgetID. Allows you to retrieve a specific individual budget."
            ),
        ] = None,
        date_to: Annotated[
            Optional[date], Field(description="Filter by start date")
        ] = None,
        date_from: Annotated[
            Optional[date], Field(description="Filter by end date")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieve a list of budgets  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param ids: Filter by BudgetID. Allows you to retrieve a specific individual budget.
        :type ids: list[str]
        :param date_to: Filter by start date
        :type date_to: date
        :param date_from: Filter by end date
        :type date_from: date
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Budgets, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "ids", "date_to", "date_from"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_budgets" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("ids") is not None:  # noqa: E501
            _query_params.append(("IDs", _params["ids"]))
            _collection_formats["IDs"] = "csv"

        if _params.get("date_to") is not None:  # noqa: E501
            if isinstance(_params["date_to"], date):
                _query_params.append(
                    (
                        "DateTo",
                        _params["date_to"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("DateTo", _params["date_to"]))

        if _params.get("date_from") is not None:  # noqa: E501
            if isinstance(_params["date_from"], date):
                _query_params.append(
                    (
                        "DateFrom",
                        _params["date_from"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("DateFrom", _params["date_from"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Budgets",
        }

        return await self.api_client.call_api(
            "/Budgets",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contact(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> Contacts:  # noqa: E501
        """Retrieves a specific contacts in a Xero organisation using a unique contact Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Contacts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contact_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contact_with_http_info(
            xero_tenant_id, contact_id, **kwargs
        )  # noqa: E501

    async def get_contact_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific contacts in a Xero organisation using a unique contact Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Contacts",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contact_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific contact by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contact_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contact_attachment_by_file_name_with_http_info(
            xero_tenant_id, contact_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_contact_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific contact by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_id", "file_name", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contact_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific contact using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contact_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contact_attachment_by_id_with_http_info(
            xero_tenant_id, contact_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_contact_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific contact using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_id", "attachment_id", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contact_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachments for a specific contact in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contact_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contact_attachments_with_http_info(
            xero_tenant_id, contact_id, **kwargs
        )  # noqa: E501

    async def get_contact_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachments for a specific contact in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contact_by_contact_number(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_number: Annotated[
            StrictStr,
            Field(
                ...,
                description="This field is read only on the Xero contact screen, used to identify contacts in external systems (max length = 50).",
            ),
        ],
        **kwargs,
    ) -> Contacts:  # noqa: E501
        """Retrieves a specific contact by contact number in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_number: This field is read only on the Xero contact screen, used to identify contacts in external systems (max length = 50). (required)
        :type contact_number: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Contacts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contact_by_contact_number_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contact_by_contact_number_with_http_info(
            xero_tenant_id, contact_number, **kwargs
        )  # noqa: E501

    async def get_contact_by_contact_number_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_number: Annotated[
            StrictStr,
            Field(
                ...,
                description="This field is read only on the Xero contact screen, used to identify contacts in external systems (max length = 50).",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific contact by contact number in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_number: This field is read only on the Xero contact screen, used to identify contacts in external systems (max length = 50). (required)
        :type contact_number: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_number"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_by_contact_number" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_number"] is not None:
            _path_params["ContactNumber"] = _params["contact_number"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Contacts",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactNumber}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contact_cis_settings(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> CISSettings:  # noqa: E501
        """Retrieves CIS settings for a specific contact in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CISSettings
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contact_cis_settings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contact_cis_settings_with_http_info(
            xero_tenant_id, contact_id, **kwargs
        )  # noqa: E501

    async def get_contact_cis_settings_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves CIS settings for a specific contact in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CISSettings, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_cis_settings" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "CISSettings",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}/CISSettings",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contact_group(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        **kwargs,
    ) -> ContactGroups:  # noqa: E501
        """Retrieves a specific contact group by using a unique contact group Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContactGroups
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contact_group_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contact_group_with_http_info(
            xero_tenant_id, contact_group_id, **kwargs
        )  # noqa: E501

    async def get_contact_group_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific contact group by using a unique contact group Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ContactGroups, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_group_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_group" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_group_id"] is not None:
            _path_params["ContactGroupID"] = _params["contact_group_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ContactGroups",
        }

        return await self.api_client.call_api(
            "/ContactGroups/{ContactGroupID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contact_groups(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ContactGroups:  # noqa: E501
        """Retrieves the contact Id and name of each contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContactGroups
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contact_groups_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contact_groups_with_http_info(
            xero_tenant_id, where, order, **kwargs
        )  # noqa: E501

    async def get_contact_groups_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves the contact Id and name of each contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ContactGroups, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_groups" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ContactGroups",
        }

        return await self.api_client.call_api(
            "/ContactGroups",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contact_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history records for a specific contact  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contact_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contact_history_with_http_info(
            xero_tenant_id, contact_id, **kwargs
        )  # noqa: E501

    async def get_contact_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history records for a specific contact  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_contacts(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        ids: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 - Up to 100 contacts will be returned in a single API call."
            ),
        ] = None,
        include_archived: Annotated[
            Optional[StrictBool],
            Field(
                description="e.g. includeArchived=true - Contacts with a status of ARCHIVED will be included in the response"
            ),
        ] = None,
        summary_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Use summaryOnly=true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient."
            ),
        ] = None,
        search_term: Annotated[
            Optional[StrictStr],
            Field(
                description="Search parameter that performs a case-insensitive text search across the Name, FirstName, LastName, ContactNumber and EmailAddress fields."
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> Contacts:  # noqa: E501
        """Retrieves all contacts in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param ids: Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call.
        :type ids: list[str]
        :param page: e.g. page=1 - Up to 100 contacts will be returned in a single API call.
        :type page: int
        :param include_archived: e.g. includeArchived=true - Contacts with a status of ARCHIVED will be included in the response
        :type include_archived: bool
        :param summary_only: Use summaryOnly=true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient.
        :type summary_only: bool
        :param search_term: Search parameter that performs a case-insensitive text search across the Name, FirstName, LastName, ContactNumber and EmailAddress fields.
        :type search_term: str
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Contacts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_contacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_contacts_with_http_info(
            xero_tenant_id,
            if_modified_since,
            where,
            order,
            ids,
            page,
            include_archived,
            summary_only,
            search_term,
            page_size,
            **kwargs,
        )  # noqa: E501

    async def get_contacts_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        ids: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 - Up to 100 contacts will be returned in a single API call."
            ),
        ] = None,
        include_archived: Annotated[
            Optional[StrictBool],
            Field(
                description="e.g. includeArchived=true - Contacts with a status of ARCHIVED will be included in the response"
            ),
        ] = None,
        summary_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Use summaryOnly=true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient."
            ),
        ] = None,
        search_term: Annotated[
            Optional[StrictStr],
            Field(
                description="Search parameter that performs a case-insensitive text search across the Name, FirstName, LastName, ContactNumber and EmailAddress fields."
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves all contacts in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param ids: Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call.
        :type ids: list[str]
        :param page: e.g. page=1 - Up to 100 contacts will be returned in a single API call.
        :type page: int
        :param include_archived: e.g. includeArchived=true - Contacts with a status of ARCHIVED will be included in the response
        :type include_archived: bool
        :param summary_only: Use summaryOnly=true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient.
        :type summary_only: bool
        :param search_term: Search parameter that performs a case-insensitive text search across the Name, FirstName, LastName, ContactNumber and EmailAddress fields.
        :type search_term: str
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "ids",
            "page",
            "include_archived",
            "summary_only",
            "search_term",
            "page_size",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contacts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("ids") is not None:  # noqa: E501
            _query_params.append(("IDs", _params["ids"]))
            _collection_formats["IDs"] = "csv"

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("include_archived") is not None:  # noqa: E501
            _query_params.append(("includeArchived", _params["include_archived"]))

        if _params.get("summary_only") is not None:  # noqa: E501
            _query_params.append(("summaryOnly", _params["summary_only"]))

        if _params.get("search_term") is not None:  # noqa: E501
            _query_params.append(("searchTerm", _params["search_term"]))

        if _params.get("page_size") is not None:  # noqa: E501
            _query_params.append(("pageSize", _params["page_size"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Contacts",
        }

        return await self.api_client.call_api(
            "/Contacts",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_credit_note(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> CreditNotes:  # noqa: E501
        """Retrieves a specific credit note using a unique credit note Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreditNotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_credit_note_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_credit_note_with_http_info(
            xero_tenant_id, credit_note_id, unitdp, **kwargs
        )  # noqa: E501

    async def get_credit_note_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific credit note using a unique credit note Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreditNotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "credit_note_id", "unitdp"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "CreditNotes",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_credit_note_as_pdf(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves credit notes as PDF files  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_credit_note_as_pdf_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_credit_note_as_pdf_with_http_info(
            xero_tenant_id, credit_note_id, **kwargs
        )  # noqa: E501

    async def get_credit_note_as_pdf_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves credit notes as PDF files  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "credit_note_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_as_pdf" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/pdf"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/pdf",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_credit_note_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment on a specific credit note by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_credit_note_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_credit_note_attachment_by_file_name_with_http_info(
            xero_tenant_id, credit_note_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_credit_note_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment on a specific credit note by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "credit_note_id", "file_name", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_credit_note_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific credit note using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_credit_note_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_credit_note_attachment_by_id_with_http_info(
            xero_tenant_id, credit_note_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_credit_note_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific credit note using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "credit_note_id",
            "attachment_id",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_credit_note_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachments for a specific credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_credit_note_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_credit_note_attachments_with_http_info(
            xero_tenant_id, credit_note_id, **kwargs
        )  # noqa: E501

    async def get_credit_note_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachments for a specific credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "credit_note_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_credit_note_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history records of a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_credit_note_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_credit_note_history_with_http_info(
            xero_tenant_id, credit_note_id, **kwargs
        )  # noqa: E501

    async def get_credit_note_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history records of a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "credit_note_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_credit_notes(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 credit notes will be returned in a single API call with line items shown for each credit note"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> CreditNotes:  # noqa: E501
        """Retrieves any credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1 – Up to 100 credit notes will be returned in a single API call with line items shown for each credit note
        :type page: int
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreditNotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_credit_notes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_credit_notes_with_http_info(
            xero_tenant_id,
            if_modified_since,
            where,
            order,
            page,
            unitdp,
            page_size,
            **kwargs,
        )  # noqa: E501

    async def get_credit_notes_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 credit notes will be returned in a single API call with line items shown for each credit note"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves any credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1 – Up to 100 credit notes will be returned in a single API call with line items shown for each credit note
        :type page: int
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreditNotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "page",
            "unitdp",
            "page_size",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_notes" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        if _params.get("page_size") is not None:  # noqa: E501
            _query_params.append(("pageSize", _params["page_size"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "CreditNotes",
        }

        return await self.api_client.call_api(
            "/CreditNotes",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_currencies(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> Currencies:  # noqa: E501
        """Retrieves currencies for your Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Currencies
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_currencies_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_currencies_with_http_info(
            xero_tenant_id, where, order, **kwargs
        )  # noqa: E501

    async def get_currencies_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves currencies for your Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Currencies, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_currencies" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Currencies",
        }

        return await self.api_client.call_api(
            "/Currencies",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Employee")
        ],
        **kwargs,
    ) -> Employees:  # noqa: E501
        """Retrieves a specific employee used in Xero payrun using a unique employee Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Unique identifier for a Employee (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Employees
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Employee")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific employee used in Xero payrun using a unique employee Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Unique identifier for a Employee (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Employees",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employees(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> Employees:  # noqa: E501
        """Retrieves employees used in Xero payrun  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Employees
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employees_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employees_with_http_info(
            xero_tenant_id, if_modified_since, where, order, **kwargs
        )  # noqa: E501

    async def get_employees_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves employees used in Xero payrun  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employees" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Employees",
        }

        return await self.api_client.call_api(
            "/Employees",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_expense_claim(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claim_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ExpenseClaim")
        ],
        **kwargs,
    ) -> ExpenseClaims:  # noqa: E501
        """Retrieves a specific expense claim using a unique expense claim Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :type expense_claim_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExpenseClaims
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_expense_claim_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_expense_claim_with_http_info(
            xero_tenant_id, expense_claim_id, **kwargs
        )  # noqa: E501

    async def get_expense_claim_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claim_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ExpenseClaim")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific expense claim using a unique expense claim Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :type expense_claim_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExpenseClaims, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "expense_claim_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_expense_claim" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["expense_claim_id"] is not None:
            _path_params["ExpenseClaimID"] = _params["expense_claim_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ExpenseClaims",
        }

        return await self.api_client.call_api(
            "/ExpenseClaims/{ExpenseClaimID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_expense_claim_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claim_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ExpenseClaim")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history records of a specific expense claim  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :type expense_claim_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_expense_claim_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_expense_claim_history_with_http_info(
            xero_tenant_id, expense_claim_id, **kwargs
        )  # noqa: E501

    async def get_expense_claim_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claim_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ExpenseClaim")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history records of a specific expense claim  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :type expense_claim_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "expense_claim_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_expense_claim_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["expense_claim_id"] is not None:
            _path_params["ExpenseClaimID"] = _params["expense_claim_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/ExpenseClaims/{ExpenseClaimID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_expense_claims(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ExpenseClaims:  # noqa: E501
        """Retrieves expense claims  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExpenseClaims
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_expense_claims_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_expense_claims_with_http_info(
            xero_tenant_id, if_modified_since, where, order, **kwargs
        )  # noqa: E501

    async def get_expense_claims_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves expense claims  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExpenseClaims, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_expense_claims" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ExpenseClaims",
        }

        return await self.api_client.call_api(
            "/ExpenseClaims",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_invoice(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> Invoices:  # noqa: E501
        """Retrieves a specific sales invoice or purchase bill using a unique invoice Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Invoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_invoice_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_invoice_with_http_info(
            xero_tenant_id, invoice_id, unitdp, **kwargs
        )  # noqa: E501

    async def get_invoice_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific sales invoice or purchase bill using a unique invoice Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Invoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "invoice_id", "unitdp"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Invoices",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_invoice_as_pdf(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves invoices or purchase bills as PDF files  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_invoice_as_pdf_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_invoice_as_pdf_with_http_info(
            xero_tenant_id, invoice_id, **kwargs
        )  # noqa: E501

    async def get_invoice_as_pdf_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves invoices or purchase bills as PDF files  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "invoice_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_as_pdf" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/pdf"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/pdf",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_invoice_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves an attachment from a specific invoice or purchase bill by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_invoice_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_invoice_attachment_by_file_name_with_http_info(
            xero_tenant_id, invoice_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_invoice_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves an attachment from a specific invoice or purchase bill by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "invoice_id", "file_name", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_invoice_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific invoices or purchase bills by using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_invoice_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_invoice_attachment_by_id_with_http_info(
            xero_tenant_id, invoice_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_invoice_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific invoices or purchase bills by using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "invoice_id", "attachment_id", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_invoice_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachments for a specific invoice or purchase bill  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_invoice_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_invoice_attachments_with_http_info(
            xero_tenant_id, invoice_id, **kwargs
        )  # noqa: E501

    async def get_invoice_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachments for a specific invoice or purchase bill  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "invoice_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_invoice_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history records for a specific invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_invoice_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_invoice_history_with_http_info(
            xero_tenant_id, invoice_id, **kwargs
        )  # noqa: E501

    async def get_invoice_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history records for a specific invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "invoice_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_invoice_reminders(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> InvoiceReminders:  # noqa: E501
        """Retrieves invoice reminder settings  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InvoiceReminders
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_invoice_reminders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_invoice_reminders_with_http_info(xero_tenant_id, **kwargs)  # noqa: E501

    async def get_invoice_reminders_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves invoice reminder settings  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InvoiceReminders, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_reminders" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "InvoiceReminders",
        }

        return await self.api_client.call_api(
            "/InvoiceReminders/Settings",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_invoices(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        ids: Annotated[
            Optional[conlist(StrictStr)],
            Field(description="Filter by a comma-separated list of InvoicesIDs."),
        ] = None,
        invoice_numbers: Annotated[
            Optional[conlist(StrictStr)],
            Field(description="Filter by a comma-separated list of InvoiceNumbers."),
        ] = None,
        contact_ids: Annotated[
            Optional[conlist(StrictStr)],
            Field(description="Filter by a comma-separated list of ContactIDs."),
        ] = None,
        statuses: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 invoices will be returned in a single API call with line items shown for each invoice"
            ),
        ] = None,
        include_archived: Annotated[
            Optional[StrictBool],
            Field(
                description="e.g. includeArchived=true - Invoices with a status of ARCHIVED will be included in the response"
            ),
        ] = None,
        created_by_my_app: Annotated[
            Optional[StrictBool],
            Field(
                description="When set to true you'll only retrieve Invoices created by your app"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        summary_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Use summaryOnly=true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient."
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        search_term: Annotated[
            Optional[StrictStr],
            Field(
                description="Search parameter that performs a case-insensitive text search across the fields e.g. InvoiceNumber, Reference."
            ),
        ] = None,
        **kwargs,
    ) -> Invoices:  # noqa: E501
        """Retrieves sales invoices or purchase bills  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param ids: Filter by a comma-separated list of InvoicesIDs.
        :type ids: list[str]
        :param invoice_numbers: Filter by a comma-separated list of InvoiceNumbers.
        :type invoice_numbers: list[str]
        :param contact_ids: Filter by a comma-separated list of ContactIDs.
        :type contact_ids: list[str]
        :param statuses: Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :type statuses: list[str]
        :param page: e.g. page=1 – Up to 100 invoices will be returned in a single API call with line items shown for each invoice
        :type page: int
        :param include_archived: e.g. includeArchived=true - Invoices with a status of ARCHIVED will be included in the response
        :type include_archived: bool
        :param created_by_my_app: When set to true you'll only retrieve Invoices created by your app
        :type created_by_my_app: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param summary_only: Use summaryOnly=true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient.
        :type summary_only: bool
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param search_term: Search parameter that performs a case-insensitive text search across the fields e.g. InvoiceNumber, Reference.
        :type search_term: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Invoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_invoices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_invoices_with_http_info(
            xero_tenant_id,
            if_modified_since,
            where,
            order,
            ids,
            invoice_numbers,
            contact_ids,
            statuses,
            page,
            include_archived,
            created_by_my_app,
            unitdp,
            summary_only,
            page_size,
            search_term,
            **kwargs,
        )  # noqa: E501

    async def get_invoices_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        ids: Annotated[
            Optional[conlist(StrictStr)],
            Field(description="Filter by a comma-separated list of InvoicesIDs."),
        ] = None,
        invoice_numbers: Annotated[
            Optional[conlist(StrictStr)],
            Field(description="Filter by a comma-separated list of InvoiceNumbers."),
        ] = None,
        contact_ids: Annotated[
            Optional[conlist(StrictStr)],
            Field(description="Filter by a comma-separated list of ContactIDs."),
        ] = None,
        statuses: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 invoices will be returned in a single API call with line items shown for each invoice"
            ),
        ] = None,
        include_archived: Annotated[
            Optional[StrictBool],
            Field(
                description="e.g. includeArchived=true - Invoices with a status of ARCHIVED will be included in the response"
            ),
        ] = None,
        created_by_my_app: Annotated[
            Optional[StrictBool],
            Field(
                description="When set to true you'll only retrieve Invoices created by your app"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        summary_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Use summaryOnly=true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient."
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        search_term: Annotated[
            Optional[StrictStr],
            Field(
                description="Search parameter that performs a case-insensitive text search across the fields e.g. InvoiceNumber, Reference."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves sales invoices or purchase bills  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param ids: Filter by a comma-separated list of InvoicesIDs.
        :type ids: list[str]
        :param invoice_numbers: Filter by a comma-separated list of InvoiceNumbers.
        :type invoice_numbers: list[str]
        :param contact_ids: Filter by a comma-separated list of ContactIDs.
        :type contact_ids: list[str]
        :param statuses: Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :type statuses: list[str]
        :param page: e.g. page=1 – Up to 100 invoices will be returned in a single API call with line items shown for each invoice
        :type page: int
        :param include_archived: e.g. includeArchived=true - Invoices with a status of ARCHIVED will be included in the response
        :type include_archived: bool
        :param created_by_my_app: When set to true you'll only retrieve Invoices created by your app
        :type created_by_my_app: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param summary_only: Use summaryOnly=true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient.
        :type summary_only: bool
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param search_term: Search parameter that performs a case-insensitive text search across the fields e.g. InvoiceNumber, Reference.
        :type search_term: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Invoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "ids",
            "invoice_numbers",
            "contact_ids",
            "statuses",
            "page",
            "include_archived",
            "created_by_my_app",
            "unitdp",
            "summary_only",
            "page_size",
            "search_term",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoices" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("ids") is not None:  # noqa: E501
            _query_params.append(("IDs", _params["ids"]))
            _collection_formats["IDs"] = "csv"

        if _params.get("invoice_numbers") is not None:  # noqa: E501
            _query_params.append(("InvoiceNumbers", _params["invoice_numbers"]))
            _collection_formats["InvoiceNumbers"] = "csv"

        if _params.get("contact_ids") is not None:  # noqa: E501
            _query_params.append(("ContactIDs", _params["contact_ids"]))
            _collection_formats["ContactIDs"] = "csv"

        if _params.get("statuses") is not None:  # noqa: E501
            _query_params.append(("Statuses", _params["statuses"]))
            _collection_formats["Statuses"] = "csv"

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("include_archived") is not None:  # noqa: E501
            _query_params.append(("includeArchived", _params["include_archived"]))

        if _params.get("created_by_my_app") is not None:  # noqa: E501
            _query_params.append(("createdByMyApp", _params["created_by_my_app"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        if _params.get("summary_only") is not None:  # noqa: E501
            _query_params.append(("summaryOnly", _params["summary_only"]))

        if _params.get("page_size") is not None:  # noqa: E501
            _query_params.append(("pageSize", _params["page_size"]))

        if _params.get("search_term") is not None:  # noqa: E501
            _query_params.append(("searchTerm", _params["search_term"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Invoices",
        }

        return await self.api_client.call_api(
            "/Invoices",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_item(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> Items:  # noqa: E501
        """Retrieves a specific item using a unique item Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Items
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_item_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_item_with_http_info(
            xero_tenant_id, item_id, unitdp, **kwargs
        )  # noqa: E501

    async def get_item_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific item using a unique item Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Items, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "item_id", "unitdp"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_item" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["item_id"] is not None:
            _path_params["ItemID"] = _params["item_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Items",
        }

        return await self.api_client.call_api(
            "/Items/{ItemID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_item_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history for a specific item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_item_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_item_history_with_http_info(
            xero_tenant_id, item_id, **kwargs
        )  # noqa: E501

    async def get_item_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history for a specific item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "item_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_item_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["item_id"] is not None:
            _path_params["ItemID"] = _params["item_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/Items/{ItemID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_items(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> Items:  # noqa: E501
        """Retrieves items  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Items
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_items_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_items_with_http_info(
            xero_tenant_id, if_modified_since, where, order, unitdp, **kwargs
        )  # noqa: E501

    async def get_items_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves items  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Items, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "unitdp",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_items" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Items",
        }

        return await self.api_client.call_api(
            "/Items",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_journal(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Journal")
        ],
        **kwargs,
    ) -> Journals:  # noqa: E501
        """Retrieves a specific journal using a unique journal Id.  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param journal_id: Unique identifier for a Journal (required)
        :type journal_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Journals
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_journal_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_journal_with_http_info(
            xero_tenant_id, journal_id, **kwargs
        )  # noqa: E501

    async def get_journal_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Journal")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific journal using a unique journal Id.  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param journal_id: Unique identifier for a Journal (required)
        :type journal_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Journals, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "journal_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_journal" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["journal_id"] is not None:
            _path_params["JournalID"] = _params["journal_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Journals",
        }

        return await self.api_client.call_api(
            "/Journals/{JournalID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_journal_by_number(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        journal_number: Annotated[
            StrictInt, Field(..., description="Number of a Journal")
        ],
        **kwargs,
    ) -> Journals:  # noqa: E501
        """Retrieves a specific journal using a unique journal number.  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param journal_number: Number of a Journal (required)
        :type journal_number: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Journals
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_journal_by_number_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_journal_by_number_with_http_info(
            xero_tenant_id, journal_number, **kwargs
        )  # noqa: E501

    async def get_journal_by_number_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        journal_number: Annotated[
            StrictInt, Field(..., description="Number of a Journal")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific journal using a unique journal number.  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param journal_number: Number of a Journal (required)
        :type journal_number: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Journals, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "journal_number"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_journal_by_number" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["journal_number"] is not None:
            _path_params["JournalNumber"] = _params["journal_number"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Journals",
        }

        return await self.api_client.call_api(
            "/Journals/{JournalNumber}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_journals(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned"
            ),
        ] = None,
        payments_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default."
            ),
        ] = None,
        **kwargs,
    ) -> Journals:  # noqa: E501
        """Retrieves journals  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param offset: Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned
        :type offset: int
        :param payments_only: Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default.
        :type payments_only: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Journals
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_journals_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_journals_with_http_info(
            xero_tenant_id, if_modified_since, offset, payments_only, **kwargs
        )  # noqa: E501

    async def get_journals_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned"
            ),
        ] = None,
        payments_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves journals  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param offset: Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned
        :type offset: int
        :param payments_only: Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default.
        :type payments_only: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Journals, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "offset", "payments_only"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_journals" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("offset") is not None:  # noqa: E501
            _query_params.append(("offset", _params["offset"]))

        if _params.get("payments_only") is not None:  # noqa: E501
            _query_params.append(("paymentsOnly", _params["payments_only"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Journals",
        }

        return await self.api_client.call_api(
            "/Journals",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_linked_transaction(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        linked_transaction_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a LinkedTransaction"),
        ],
        **kwargs,
    ) -> LinkedTransactions:  # noqa: E501
        """Retrieves a specific linked transaction (billable expenses) using a unique linked transaction Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :type linked_transaction_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LinkedTransactions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_linked_transaction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_linked_transaction_with_http_info(
            xero_tenant_id, linked_transaction_id, **kwargs
        )  # noqa: E501

    async def get_linked_transaction_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        linked_transaction_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a LinkedTransaction"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific linked transaction (billable expenses) using a unique linked transaction Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :type linked_transaction_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LinkedTransactions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "linked_transaction_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_linked_transaction" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["linked_transaction_id"] is not None:
            _path_params["LinkedTransactionID"] = _params["linked_transaction_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LinkedTransactions",
        }

        return await self.api_client.call_api(
            "/LinkedTransactions/{LinkedTransactionID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_linked_transactions(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page=1."
            ),
        ] = None,
        linked_transaction_id: Annotated[
            Optional[StrictStr],
            Field(description="The Xero identifier for an Linked Transaction"),
        ] = None,
        source_transaction_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by the SourceTransactionID. Get the linked transactions created from a particular ACCPAY invoice"
            ),
        ] = None,
        contact_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer."
            ),
        ] = None,
        status: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by the combination of ContactID and Status. Get  the linked transactions associated to a  customer and with a status"
            ),
        ] = None,
        target_transaction_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice"
            ),
        ] = None,
        **kwargs,
    ) -> LinkedTransactions:  # noqa: E501
        """Retrieves linked transactions (billable expenses)  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page=1.
        :type page: int
        :param linked_transaction_id: The Xero identifier for an Linked Transaction
        :type linked_transaction_id: str
        :param source_transaction_id: Filter by the SourceTransactionID. Get the linked transactions created from a particular ACCPAY invoice
        :type source_transaction_id: str
        :param contact_id: Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer.
        :type contact_id: str
        :param status: Filter by the combination of ContactID and Status. Get  the linked transactions associated to a  customer and with a status
        :type status: str
        :param target_transaction_id: Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice
        :type target_transaction_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LinkedTransactions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_linked_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_linked_transactions_with_http_info(
            xero_tenant_id,
            page,
            linked_transaction_id,
            source_transaction_id,
            contact_id,
            status,
            target_transaction_id,
            **kwargs,
        )  # noqa: E501

    async def get_linked_transactions_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page=1."
            ),
        ] = None,
        linked_transaction_id: Annotated[
            Optional[StrictStr],
            Field(description="The Xero identifier for an Linked Transaction"),
        ] = None,
        source_transaction_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by the SourceTransactionID. Get the linked transactions created from a particular ACCPAY invoice"
            ),
        ] = None,
        contact_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer."
            ),
        ] = None,
        status: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by the combination of ContactID and Status. Get  the linked transactions associated to a  customer and with a status"
            ),
        ] = None,
        target_transaction_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves linked transactions (billable expenses)  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page=1.
        :type page: int
        :param linked_transaction_id: The Xero identifier for an Linked Transaction
        :type linked_transaction_id: str
        :param source_transaction_id: Filter by the SourceTransactionID. Get the linked transactions created from a particular ACCPAY invoice
        :type source_transaction_id: str
        :param contact_id: Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer.
        :type contact_id: str
        :param status: Filter by the combination of ContactID and Status. Get  the linked transactions associated to a  customer and with a status
        :type status: str
        :param target_transaction_id: Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice
        :type target_transaction_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LinkedTransactions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "page",
            "linked_transaction_id",
            "source_transaction_id",
            "contact_id",
            "status",
            "target_transaction_id",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_linked_transactions" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("linked_transaction_id") is not None:  # noqa: E501
            _query_params.append(
                ("LinkedTransactionID", _params["linked_transaction_id"])
            )

        if _params.get("source_transaction_id") is not None:  # noqa: E501
            _query_params.append(
                ("SourceTransactionID", _params["source_transaction_id"])
            )

        if _params.get("contact_id") is not None:  # noqa: E501
            _query_params.append(("ContactID", _params["contact_id"]))

        if _params.get("status") is not None:  # noqa: E501
            _query_params.append(("Status", _params["status"]))

        if _params.get("target_transaction_id") is not None:  # noqa: E501
            _query_params.append(
                ("TargetTransactionID", _params["target_transaction_id"])
            )

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LinkedTransactions",
        }

        return await self.api_client.call_api(
            "/LinkedTransactions",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_manual_journal(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        **kwargs,
    ) -> ManualJournals:  # noqa: E501
        """Retrieves a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ManualJournals
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_manual_journal_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_manual_journal_with_http_info(
            xero_tenant_id, manual_journal_id, **kwargs
        )  # noqa: E501

    async def get_manual_journal_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ManualJournals, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "manual_journal_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journal" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["manual_journal_id"] is not None:
            _path_params["ManualJournalID"] = _params["manual_journal_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ManualJournals",
        }

        return await self.api_client.call_api(
            "/ManualJournals/{ManualJournalID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_manual_journal_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific manual journal by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_manual_journal_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_manual_journal_attachment_by_file_name_with_http_info(
            xero_tenant_id, manual_journal_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_manual_journal_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific manual journal by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "manual_journal_id",
            "file_name",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journal_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["manual_journal_id"] is not None:
            _path_params["ManualJournalID"] = _params["manual_journal_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/ManualJournals/{ManualJournalID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_manual_journal_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Allows you to retrieve a specific attachment from a specific manual journal using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_manual_journal_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_manual_journal_attachment_by_id_with_http_info(
            xero_tenant_id, manual_journal_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_manual_journal_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Allows you to retrieve a specific attachment from a specific manual journal using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "manual_journal_id",
            "attachment_id",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journal_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["manual_journal_id"] is not None:
            _path_params["ManualJournalID"] = _params["manual_journal_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/ManualJournals/{ManualJournalID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_manual_journal_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachment for a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_manual_journal_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_manual_journal_attachments_with_http_info(
            xero_tenant_id, manual_journal_id, **kwargs
        )  # noqa: E501

    async def get_manual_journal_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachment for a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "manual_journal_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journal_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["manual_journal_id"] is not None:
            _path_params["ManualJournalID"] = _params["manual_journal_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/ManualJournals/{ManualJournalID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_manual_journals(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> ManualJournals:  # noqa: E501
        """Retrieves manual journals  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1 – Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment
        :type page: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ManualJournals
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_manual_journals_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_manual_journals_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, page_size, **kwargs
        )  # noqa: E501

    async def get_manual_journals_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves manual journals  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1 – Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment
        :type page: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ManualJournals, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "page",
            "page_size",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journals" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("page_size") is not None:  # noqa: E501
            _query_params.append(("pageSize", _params["page_size"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ManualJournals",
        }

        return await self.api_client.call_api(
            "/ManualJournals",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_manual_journals_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history for a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_manual_journals_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_manual_journals_history_with_http_info(
            xero_tenant_id, manual_journal_id, **kwargs
        )  # noqa: E501

    async def get_manual_journals_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history for a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "manual_journal_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journals_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["manual_journal_id"] is not None:
            _path_params["ManualJournalID"] = _params["manual_journal_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/ManualJournals/{ManualJournalID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_online_invoice(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        **kwargs,
    ) -> OnlineInvoices:  # noqa: E501
        """Retrieves a URL to an online invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OnlineInvoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_online_invoice_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_online_invoice_with_http_info(
            xero_tenant_id, invoice_id, **kwargs
        )  # noqa: E501

    async def get_online_invoice_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a URL to an online invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OnlineInvoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "invoice_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_online_invoice" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "OnlineInvoices",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/OnlineInvoice",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_organisation_actions(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> Actions:  # noqa: E501
        """Retrieves a list of the key actions your app has permission to perform in the connected Xero organisation.  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Actions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_organisation_actions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_organisation_actions_with_http_info(
            xero_tenant_id, **kwargs
        )  # noqa: E501

    async def get_organisation_actions_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a list of the key actions your app has permission to perform in the connected Xero organisation.  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Actions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organisation_actions" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Actions",
        }

        return await self.api_client.call_api(
            "/Organisation/Actions",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_organisation_cis_settings(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        organisation_id: Annotated[
            StrictStr,
            Field(..., description="The unique Xero identifier for an organisation"),
        ],
        **kwargs,
    ) -> CISOrgSettings:  # noqa: E501
        """Retrieves the CIS settings for the Xero organistaion.  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param organisation_id: The unique Xero identifier for an organisation (required)
        :type organisation_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CISOrgSettings
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_organisation_cis_settings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_organisation_cis_settings_with_http_info(
            xero_tenant_id, organisation_id, **kwargs
        )  # noqa: E501

    async def get_organisation_cis_settings_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        organisation_id: Annotated[
            StrictStr,
            Field(..., description="The unique Xero identifier for an organisation"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves the CIS settings for the Xero organistaion.  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param organisation_id: The unique Xero identifier for an organisation (required)
        :type organisation_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CISOrgSettings, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "organisation_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organisation_cis_settings" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["organisation_id"] is not None:
            _path_params["OrganisationID"] = _params["organisation_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "CISOrgSettings",
        }

        return await self.api_client.call_api(
            "/Organisation/{OrganisationID}/CISSettings",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_organisations(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> Organisations:  # noqa: E501
        """Retrieves Xero organisation details  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Organisations
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_organisations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_organisations_with_http_info(xero_tenant_id, **kwargs)  # noqa: E501

    async def get_organisations_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves Xero organisation details  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Organisations, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organisations" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Organisations",
        }

        return await self.api_client.call_api(
            "/Organisation",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_overpayment(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        **kwargs,
    ) -> Overpayments:  # noqa: E501
        """Retrieves a specific overpayment using a unique overpayment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Overpayments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_overpayment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_overpayment_with_http_info(
            xero_tenant_id, overpayment_id, **kwargs
        )  # noqa: E501

    async def get_overpayment_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific overpayment using a unique overpayment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Overpayments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "overpayment_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_overpayment" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["overpayment_id"] is not None:
            _path_params["OverpaymentID"] = _params["overpayment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Overpayments",
        }

        return await self.api_client.call_api(
            "/Overpayments/{OverpaymentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_overpayment_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history records of a specific overpayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_overpayment_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_overpayment_history_with_http_info(
            xero_tenant_id, overpayment_id, **kwargs
        )  # noqa: E501

    async def get_overpayment_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        overpayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Overpayment")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history records of a specific overpayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param overpayment_id: Unique identifier for a Overpayment (required)
        :type overpayment_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "overpayment_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_overpayment_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["overpayment_id"] is not None:
            _path_params["OverpaymentID"] = _params["overpayment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/Overpayments/{OverpaymentID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_overpayments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> Overpayments:  # noqa: E501
        """Retrieves overpayments  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1 – Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment
        :type page: int
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Overpayments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_overpayments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_overpayments_with_http_info(
            xero_tenant_id,
            if_modified_since,
            where,
            order,
            page,
            unitdp,
            page_size,
            **kwargs,
        )  # noqa: E501

    async def get_overpayments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves overpayments  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1 – Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment
        :type page: int
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Overpayments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "page",
            "unitdp",
            "page_size",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_overpayments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        if _params.get("page_size") is not None:  # noqa: E501
            _query_params.append(("pageSize", _params["page_size"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Overpayments",
        }

        return await self.api_client.call_api(
            "/Overpayments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_payment(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Payment")
        ],
        **kwargs,
    ) -> Payments:  # noqa: E501
        """Retrieves a specific payment for invoices and credit notes using a unique payment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_id: Unique identifier for a Payment (required)
        :type payment_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Payments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_payment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_payment_with_http_info(
            xero_tenant_id, payment_id, **kwargs
        )  # noqa: E501

    async def get_payment_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Payment")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific payment for invoices and credit notes using a unique payment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_id: Unique identifier for a Payment (required)
        :type payment_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Payments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "payment_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payment" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["payment_id"] is not None:
            _path_params["PaymentID"] = _params["payment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Payments",
        }

        return await self.api_client.call_api(
            "/Payments/{PaymentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_payment_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Payment")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history records of a specific payment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_id: Unique identifier for a Payment (required)
        :type payment_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_payment_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_payment_history_with_http_info(
            xero_tenant_id, payment_id, **kwargs
        )  # noqa: E501

    async def get_payment_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Payment")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history records of a specific payment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payment_id: Unique identifier for a Payment (required)
        :type payment_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "payment_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payment_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["payment_id"] is not None:
            _path_params["PaymentID"] = _params["payment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/Payments/{PaymentID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_payment_services(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> PaymentServices:  # noqa: E501
        """Retrieves payment services  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaymentServices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_payment_services_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_payment_services_with_http_info(xero_tenant_id, **kwargs)  # noqa: E501

    async def get_payment_services_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves payment services  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaymentServices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payment_services" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PaymentServices",
        }

        return await self.api_client.call_api(
            "/PaymentServices",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_payments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Up to 100 payments will be returned in a single API call"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> Payments:  # noqa: E501
        """Retrieves payments for invoices and credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: Up to 100 payments will be returned in a single API call
        :type page: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Payments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_payments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_payments_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, page_size, **kwargs
        )  # noqa: E501

    async def get_payments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Up to 100 payments will be returned in a single API call"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves payments for invoices and credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: Up to 100 payments will be returned in a single API call
        :type page: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Payments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "page",
            "page_size",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("page_size") is not None:  # noqa: E501
            _query_params.append(("pageSize", _params["page_size"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Payments",
        }

        return await self.api_client.call_api(
            "/Payments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_prepayment(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        **kwargs,
    ) -> Prepayments:  # noqa: E501
        """Allows you to retrieve a specified prepayments  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Prepayments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_prepayment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_prepayment_with_http_info(
            xero_tenant_id, prepayment_id, **kwargs
        )  # noqa: E501

    async def get_prepayment_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Allows you to retrieve a specified prepayments  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Prepayments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "prepayment_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prepayment" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["prepayment_id"] is not None:
            _path_params["PrepaymentID"] = _params["prepayment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Prepayments",
        }

        return await self.api_client.call_api(
            "/Prepayments/{PrepaymentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_prepayment_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history record for a specific prepayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_prepayment_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_prepayment_history_with_http_info(
            xero_tenant_id, prepayment_id, **kwargs
        )  # noqa: E501

    async def get_prepayment_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        prepayment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PrePayment")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history record for a specific prepayment  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param prepayment_id: Unique identifier for a PrePayment (required)
        :type prepayment_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "prepayment_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prepayment_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["prepayment_id"] is not None:
            _path_params["PrepaymentID"] = _params["prepayment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/Prepayments/{PrepaymentID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_prepayments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> Prepayments:  # noqa: E501
        """Retrieves prepayments  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1 – Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment
        :type page: int
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Prepayments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_prepayments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_prepayments_with_http_info(
            xero_tenant_id,
            if_modified_since,
            where,
            order,
            page,
            unitdp,
            page_size,
            **kwargs,
        )  # noqa: E501

    async def get_prepayments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves prepayments  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1 – Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment
        :type page: int
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Prepayments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "page",
            "unitdp",
            "page_size",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prepayments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        if _params.get("page_size") is not None:  # noqa: E501
            _query_params.append(("pageSize", _params["page_size"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Prepayments",
        }

        return await self.api_client.call_api(
            "/Prepayments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_purchase_order(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        **kwargs,
    ) -> PurchaseOrders:  # noqa: E501
        """Retrieves a specific purchase order using a unique purchase order Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PurchaseOrders
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_purchase_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_purchase_order_with_http_info(
            xero_tenant_id, purchase_order_id, **kwargs
        )  # noqa: E501

    async def get_purchase_order_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific purchase order using a unique purchase order Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "purchase_order_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_order" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PurchaseOrders",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_purchase_order_as_pdf(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves specific purchase order as PDF files using a unique purchase order Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_purchase_order_as_pdf_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_purchase_order_as_pdf_with_http_info(
            xero_tenant_id, purchase_order_id, **kwargs
        )  # noqa: E501

    async def get_purchase_order_as_pdf_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves specific purchase order as PDF files using a unique purchase order Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "purchase_order_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_order_as_pdf" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/pdf"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}/pdf",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_purchase_order_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment for a specific purchase order by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_purchase_order_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_purchase_order_attachment_by_file_name_with_http_info(
            xero_tenant_id, purchase_order_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_purchase_order_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment for a specific purchase order by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "purchase_order_id",
            "file_name",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_order_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_purchase_order_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves specific attachment for a specific purchase order using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_purchase_order_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_purchase_order_attachment_by_id_with_http_info(
            xero_tenant_id, purchase_order_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_purchase_order_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves specific attachment for a specific purchase order using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "purchase_order_id",
            "attachment_id",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_order_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_purchase_order_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachments for a specific purchase order  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_purchase_order_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_purchase_order_attachments_with_http_info(
            xero_tenant_id, purchase_order_id, **kwargs
        )  # noqa: E501

    async def get_purchase_order_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachments for a specific purchase order  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "purchase_order_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_order_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_purchase_order_by_number(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_number: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PurchaseOrder")
        ],
        **kwargs,
    ) -> PurchaseOrders:  # noqa: E501
        """Retrieves a specific purchase order using purchase order number  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_number: Unique identifier for a PurchaseOrder (required)
        :type purchase_order_number: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PurchaseOrders
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_purchase_order_by_number_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_purchase_order_by_number_with_http_info(
            xero_tenant_id, purchase_order_number, **kwargs
        )  # noqa: E501

    async def get_purchase_order_by_number_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_number: Annotated[
            StrictStr, Field(..., description="Unique identifier for a PurchaseOrder")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific purchase order using purchase order number  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_number: Unique identifier for a PurchaseOrder (required)
        :type purchase_order_number: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "purchase_order_number"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_order_by_number" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_number"] is not None:
            _path_params["PurchaseOrderNumber"] = _params["purchase_order_number"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PurchaseOrders",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderNumber}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_purchase_order_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history for a specific purchase order  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_purchase_order_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_purchase_order_history_with_http_info(
            xero_tenant_id, purchase_order_id, **kwargs
        )  # noqa: E501

    async def get_purchase_order_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history for a specific purchase order  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "purchase_order_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_order_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_purchase_orders(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        status: Annotated[
            Optional[StrictStr], Field(description="Filter by purchase order status")
        ] = None,
        date_from: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31"
            ),
        ] = None,
        date_to: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31"
            ),
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="To specify a page, append the page parameter to the URL e.g. ?page=1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page=2 and continuing this process until no more results are returned."
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> PurchaseOrders:  # noqa: E501
        """Retrieves purchase orders  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param status: Filter by purchase order status
        :type status: str
        :param date_from: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
        :type date_from: str
        :param date_to: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
        :type date_to: str
        :param order: Order by an any element
        :type order: str
        :param page: To specify a page, append the page parameter to the URL e.g. ?page=1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page=2 and continuing this process until no more results are returned.
        :type page: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PurchaseOrders
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_purchase_orders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_purchase_orders_with_http_info(
            xero_tenant_id,
            if_modified_since,
            status,
            date_from,
            date_to,
            order,
            page,
            page_size,
            **kwargs,
        )  # noqa: E501

    async def get_purchase_orders_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        status: Annotated[
            Optional[StrictStr], Field(description="Filter by purchase order status")
        ] = None,
        date_from: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31"
            ),
        ] = None,
        date_to: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31"
            ),
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="To specify a page, append the page parameter to the URL e.g. ?page=1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page=2 and continuing this process until no more results are returned."
            ),
        ] = None,
        page_size: Annotated[
            Optional[StrictInt],
            Field(description="Number of records to retrieve per page"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves purchase orders  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param status: Filter by purchase order status
        :type status: str
        :param date_from: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
        :type date_from: str
        :param date_to: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
        :type date_to: str
        :param order: Order by an any element
        :type order: str
        :param page: To specify a page, append the page parameter to the URL e.g. ?page=1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page=2 and continuing this process until no more results are returned.
        :type page: int
        :param page_size: Number of records to retrieve per page
        :type page_size: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "status",
            "date_from",
            "date_to",
            "order",
            "page",
            "page_size",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_orders" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("status") is not None:  # noqa: E501
            _query_params.append(("Status", _params["status"]))

        if _params.get("date_from") is not None:  # noqa: E501
            _query_params.append(("DateFrom", _params["date_from"]))

        if _params.get("date_to") is not None:  # noqa: E501
            _query_params.append(("DateTo", _params["date_to"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("page_size") is not None:  # noqa: E501
            _query_params.append(("pageSize", _params["page_size"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PurchaseOrders",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_quote(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        **kwargs,
    ) -> Quotes:  # noqa: E501
        """Retrieves a specific quote using a unique quote Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Quotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_quote_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_quote_with_http_info(xero_tenant_id, quote_id, **kwargs)  # noqa: E501

    async def get_quote_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific quote using a unique quote Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Quotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "quote_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quote" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Quotes",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_quote_as_pdf(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific quote as a PDF file using a unique quote Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_quote_as_pdf_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_quote_as_pdf_with_http_info(
            xero_tenant_id, quote_id, **kwargs
        )  # noqa: E501

    async def get_quote_as_pdf_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific quote as a PDF file using a unique quote Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "quote_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quote_as_pdf" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/pdf"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}/pdf",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_quote_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific quote by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_quote_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_quote_attachment_by_file_name_with_http_info(
            xero_tenant_id, quote_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_quote_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific quote by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "quote_id", "file_name", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quote_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_quote_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific quote using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_quote_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_quote_attachment_by_id_with_http_info(
            xero_tenant_id, quote_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_quote_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific quote using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "quote_id", "attachment_id", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quote_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_quote_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachments for a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_quote_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_quote_attachments_with_http_info(
            xero_tenant_id, quote_id, **kwargs
        )  # noqa: E501

    async def get_quote_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachments for a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "quote_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quote_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_quote_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history records of a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_quote_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_quote_history_with_http_info(
            xero_tenant_id, quote_id, **kwargs
        )  # noqa: E501

    async def get_quote_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history records of a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "quote_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quote_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_quotes(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        date_from: Annotated[
            Optional[date],
            Field(description="Filter for quotes after a particular date"),
        ] = None,
        date_to: Annotated[
            Optional[date],
            Field(description="Filter for quotes before a particular date"),
        ] = None,
        expiry_date_from: Annotated[
            Optional[date],
            Field(description="Filter for quotes expiring after a particular date"),
        ] = None,
        expiry_date_to: Annotated[
            Optional[date],
            Field(description="Filter for quotes before a particular date"),
        ] = None,
        contact_id: Annotated[
            Optional[StrictStr],
            Field(description="Filter for quotes belonging to a particular contact"),
        ] = None,
        status: Annotated[
            Optional[StrictStr],
            Field(description="Filter for quotes of a particular Status"),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 Quotes will be returned in a single API call with line items shown for each quote"
            ),
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        quote_number: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by quote number (e.g. GET https://.../Quotes?QuoteNumber=QU-0001)"
            ),
        ] = None,
        **kwargs,
    ) -> Quotes:  # noqa: E501
        """Retrieves sales quotes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param date_from: Filter for quotes after a particular date
        :type date_from: date
        :param date_to: Filter for quotes before a particular date
        :type date_to: date
        :param expiry_date_from: Filter for quotes expiring after a particular date
        :type expiry_date_from: date
        :param expiry_date_to: Filter for quotes before a particular date
        :type expiry_date_to: date
        :param contact_id: Filter for quotes belonging to a particular contact
        :type contact_id: str
        :param status: Filter for quotes of a particular Status
        :type status: str
        :param page: e.g. page=1 – Up to 100 Quotes will be returned in a single API call with line items shown for each quote
        :type page: int
        :param order: Order by an any element
        :type order: str
        :param quote_number: Filter by quote number (e.g. GET https://.../Quotes?QuoteNumber=QU-0001)
        :type quote_number: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Quotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_quotes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_quotes_with_http_info(
            xero_tenant_id,
            if_modified_since,
            date_from,
            date_to,
            expiry_date_from,
            expiry_date_to,
            contact_id,
            status,
            page,
            order,
            quote_number,
            **kwargs,
        )  # noqa: E501

    async def get_quotes_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        date_from: Annotated[
            Optional[date],
            Field(description="Filter for quotes after a particular date"),
        ] = None,
        date_to: Annotated[
            Optional[date],
            Field(description="Filter for quotes before a particular date"),
        ] = None,
        expiry_date_from: Annotated[
            Optional[date],
            Field(description="Filter for quotes expiring after a particular date"),
        ] = None,
        expiry_date_to: Annotated[
            Optional[date],
            Field(description="Filter for quotes before a particular date"),
        ] = None,
        contact_id: Annotated[
            Optional[StrictStr],
            Field(description="Filter for quotes belonging to a particular contact"),
        ] = None,
        status: Annotated[
            Optional[StrictStr],
            Field(description="Filter for quotes of a particular Status"),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1 – Up to 100 Quotes will be returned in a single API call with line items shown for each quote"
            ),
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        quote_number: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter by quote number (e.g. GET https://.../Quotes?QuoteNumber=QU-0001)"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves sales quotes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param date_from: Filter for quotes after a particular date
        :type date_from: date
        :param date_to: Filter for quotes before a particular date
        :type date_to: date
        :param expiry_date_from: Filter for quotes expiring after a particular date
        :type expiry_date_from: date
        :param expiry_date_to: Filter for quotes before a particular date
        :type expiry_date_to: date
        :param contact_id: Filter for quotes belonging to a particular contact
        :type contact_id: str
        :param status: Filter for quotes of a particular Status
        :type status: str
        :param page: e.g. page=1 – Up to 100 Quotes will be returned in a single API call with line items shown for each quote
        :type page: int
        :param order: Order by an any element
        :type order: str
        :param quote_number: Filter by quote number (e.g. GET https://.../Quotes?QuoteNumber=QU-0001)
        :type quote_number: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Quotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "date_from",
            "date_to",
            "expiry_date_from",
            "expiry_date_to",
            "contact_id",
            "status",
            "page",
            "order",
            "quote_number",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quotes" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("date_from") is not None:  # noqa: E501
            if isinstance(_params["date_from"], date):
                _query_params.append(
                    (
                        "DateFrom",
                        _params["date_from"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("DateFrom", _params["date_from"]))

        if _params.get("date_to") is not None:  # noqa: E501
            if isinstance(_params["date_to"], date):
                _query_params.append(
                    (
                        "DateTo",
                        _params["date_to"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("DateTo", _params["date_to"]))

        if _params.get("expiry_date_from") is not None:  # noqa: E501
            if isinstance(_params["expiry_date_from"], date):
                _query_params.append(
                    (
                        "ExpiryDateFrom",
                        _params["expiry_date_from"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("ExpiryDateFrom", _params["expiry_date_from"]))

        if _params.get("expiry_date_to") is not None:  # noqa: E501
            if isinstance(_params["expiry_date_to"], date):
                _query_params.append(
                    (
                        "ExpiryDateTo",
                        _params["expiry_date_to"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("ExpiryDateTo", _params["expiry_date_to"]))

        if _params.get("contact_id") is not None:  # noqa: E501
            _query_params.append(("ContactID", _params["contact_id"]))

        if _params.get("status") is not None:  # noqa: E501
            _query_params.append(("Status", _params["status"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("quote_number") is not None:  # noqa: E501
            _query_params.append(("QuoteNumber", _params["quote_number"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Quotes",
        }

        return await self.api_client.call_api(
            "/Quotes",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_receipt(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> Receipts:  # noqa: E501
        """Retrieves a specific draft expense claim receipt by using a unique receipt Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Receipts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_receipt_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_receipt_with_http_info(
            xero_tenant_id, receipt_id, unitdp, **kwargs
        )  # noqa: E501

    async def get_receipt_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific draft expense claim receipt by using a unique receipt Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Receipts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "receipt_id", "unitdp"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["receipt_id"] is not None:
            _path_params["ReceiptID"] = _params["receipt_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Receipts",
        }

        return await self.api_client.call_api(
            "/Receipts/{ReceiptID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_receipt_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific expense claim receipts by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_receipt_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_receipt_attachment_by_file_name_with_http_info(
            xero_tenant_id, receipt_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_receipt_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific expense claim receipts by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "receipt_id", "file_name", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["receipt_id"] is not None:
            _path_params["ReceiptID"] = _params["receipt_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Receipts/{ReceiptID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_receipt_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachments from a specific expense claim receipts by using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_receipt_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_receipt_attachment_by_id_with_http_info(
            xero_tenant_id, receipt_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_receipt_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachments from a specific expense claim receipts by using a unique attachment Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "receipt_id", "attachment_id", "content_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["receipt_id"] is not None:
            _path_params["ReceiptID"] = _params["receipt_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/Receipts/{ReceiptID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_receipt_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachments for a specific expense claim receipt  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_receipt_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_receipt_attachments_with_http_info(
            xero_tenant_id, receipt_id, **kwargs
        )  # noqa: E501

    async def get_receipt_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachments for a specific expense claim receipt  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "receipt_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["receipt_id"] is not None:
            _path_params["ReceiptID"] = _params["receipt_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/Receipts/{ReceiptID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_receipt_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves a history record for a specific receipt  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_receipt_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_receipt_history_with_http_info(
            xero_tenant_id, receipt_id, **kwargs
        )  # noqa: E501

    async def get_receipt_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a history record for a specific receipt  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "receipt_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["receipt_id"] is not None:
            _path_params["ReceiptID"] = _params["receipt_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/Receipts/{ReceiptID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_receipts(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> Receipts:  # noqa: E501
        """Retrieves draft expense claim receipts for any user  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Receipts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_receipts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_receipts_with_http_info(
            xero_tenant_id, if_modified_since, where, order, unitdp, **kwargs
        )  # noqa: E501

    async def get_receipts_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves draft expense claim receipts for any user  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Receipts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "if_modified_since",
            "where",
            "order",
            "unitdp",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Receipts",
        }

        return await self.api_client.call_api(
            "/Receipts",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_repeating_invoice(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        **kwargs,
    ) -> RepeatingInvoices:  # noqa: E501
        """Retrieves a specific repeating invoice by using a unique repeating invoice Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RepeatingInvoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_repeating_invoice_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_repeating_invoice_with_http_info(
            xero_tenant_id, repeating_invoice_id, **kwargs
        )  # noqa: E501

    async def get_repeating_invoice_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific repeating invoice by using a unique repeating invoice Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RepeatingInvoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "repeating_invoice_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["repeating_invoice_id"] is not None:
            _path_params["RepeatingInvoiceID"] = _params["repeating_invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "RepeatingInvoices",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices/{RepeatingInvoiceID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_repeating_invoice_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific repeating invoices by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_repeating_invoice_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_repeating_invoice_attachment_by_file_name_with_http_info(
            xero_tenant_id, repeating_invoice_id, file_name, content_type, **kwargs
        )  # noqa: E501

    async def get_repeating_invoice_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific repeating invoices by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "repeating_invoice_id",
            "file_name",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["repeating_invoice_id"] is not None:
            _path_params["RepeatingInvoiceID"] = _params["repeating_invoice_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_repeating_invoice_attachment_by_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Retrieves a specific attachment from a specific repeating invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_repeating_invoice_attachment_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_repeating_invoice_attachment_by_id_with_http_info(
            xero_tenant_id, repeating_invoice_id, attachment_id, content_type, **kwargs
        )  # noqa: E501

    async def get_repeating_invoice_attachment_by_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        attachment_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Attachment object")
        ],
        content_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf",
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific attachment from a specific repeating invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param attachment_id: Unique identifier for Attachment object (required)
        :type attachment_id: str
        :param content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :type content_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "repeating_invoice_id",
            "attachment_id",
            "content_type",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice_attachment_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["repeating_invoice_id"] is not None:
            _path_params["RepeatingInvoiceID"] = _params["repeating_invoice_id"]

        if _params["attachment_id"] is not None:
            _path_params["AttachmentID"] = _params["attachment_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["content_type"] is not None:
            _header_params["contentType"] = _params["content_type"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/octet-stream"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{AttachmentID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_repeating_invoice_attachments(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Retrieves attachments from a specific repeating invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_repeating_invoice_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_repeating_invoice_attachments_with_http_info(
            xero_tenant_id, repeating_invoice_id, **kwargs
        )  # noqa: E501

    async def get_repeating_invoice_attachments_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves attachments from a specific repeating invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "repeating_invoice_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice_attachments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["repeating_invoice_id"] is not None:
            _path_params["RepeatingInvoiceID"] = _params["repeating_invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_repeating_invoice_history(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        **kwargs,
    ) -> HistoryRecords:  # noqa: E501
        """Retrieves history record for a specific repeating invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoryRecords
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_repeating_invoice_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_repeating_invoice_history_with_http_info(
            xero_tenant_id, repeating_invoice_id, **kwargs
        )  # noqa: E501

    async def get_repeating_invoice_history_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves history record for a specific repeating invoice  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "repeating_invoice_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice_history" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["repeating_invoice_id"] is not None:
            _path_params["RepeatingInvoiceID"] = _params["repeating_invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "HistoryRecords",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices/{RepeatingInvoiceID}/History",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_repeating_invoices(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> RepeatingInvoices:  # noqa: E501
        """Retrieves repeating invoices  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RepeatingInvoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_repeating_invoices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_repeating_invoices_with_http_info(
            xero_tenant_id, where, order, **kwargs
        )  # noqa: E501

    async def get_repeating_invoices_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves repeating invoices  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RepeatingInvoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoices" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "RepeatingInvoices",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_aged_payables_by_contact(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date of the Aged Payables By Contact report"),
        ] = None,
        from_date: Annotated[
            Optional[date],
            Field(description="filter by the from date of the report e.g. 2021-02-01"),
        ] = None,
        to_date: Annotated[
            Optional[date],
            Field(description="filter by the to date of the report e.g. 2021-02-28"),
        ] = None,
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves report for aged payables by contact  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param var_date: The date of the Aged Payables By Contact report
        :type var_date: date
        :param from_date: filter by the from date of the report e.g. 2021-02-01
        :type from_date: date
        :param to_date: filter by the to date of the report e.g. 2021-02-28
        :type to_date: date
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_aged_payables_by_contact_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_aged_payables_by_contact_with_http_info(
            xero_tenant_id, contact_id, var_date, from_date, to_date, **kwargs
        )  # noqa: E501

    async def get_report_aged_payables_by_contact_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date of the Aged Payables By Contact report"),
        ] = None,
        from_date: Annotated[
            Optional[date],
            Field(description="filter by the from date of the report e.g. 2021-02-01"),
        ] = None,
        to_date: Annotated[
            Optional[date],
            Field(description="filter by the to date of the report e.g. 2021-02-28"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves report for aged payables by contact  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param var_date: The date of the Aged Payables By Contact report
        :type var_date: date
        :param from_date: filter by the from date of the report e.g. 2021-02-01
        :type from_date: date
        :param to_date: filter by the to date of the report e.g. 2021-02-28
        :type to_date: date
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "contact_id",
            "var_date",
            "from_date",
            "to_date",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_aged_payables_by_contact" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("contact_id") is not None:  # noqa: E501
            _query_params.append(("contactId", _params["contact_id"]))

        if _params.get("var_date") is not None:  # noqa: E501
            if isinstance(_params["var_date"], date):
                _query_params.append(
                    (
                        "date",
                        _params["var_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("date", _params["var_date"]))

        if _params.get("from_date") is not None:  # noqa: E501
            if isinstance(_params["from_date"], date):
                _query_params.append(
                    (
                        "fromDate",
                        _params["from_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("fromDate", _params["from_date"]))

        if _params.get("to_date") is not None:  # noqa: E501
            if isinstance(_params["to_date"], date):
                _query_params.append(
                    (
                        "toDate",
                        _params["to_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("toDate", _params["to_date"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports/AgedPayablesByContact",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_aged_receivables_by_contact(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date of the Aged Receivables By Contact report"),
        ] = None,
        from_date: Annotated[
            Optional[date],
            Field(description="filter by the from date of the report e.g. 2021-02-01"),
        ] = None,
        to_date: Annotated[
            Optional[date],
            Field(description="filter by the to date of the report e.g. 2021-02-28"),
        ] = None,
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves report for aged receivables by contact  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param var_date: The date of the Aged Receivables By Contact report
        :type var_date: date
        :param from_date: filter by the from date of the report e.g. 2021-02-01
        :type from_date: date
        :param to_date: filter by the to date of the report e.g. 2021-02-28
        :type to_date: date
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_aged_receivables_by_contact_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_aged_receivables_by_contact_with_http_info(
            xero_tenant_id, contact_id, var_date, from_date, to_date, **kwargs
        )  # noqa: E501

    async def get_report_aged_receivables_by_contact_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date of the Aged Receivables By Contact report"),
        ] = None,
        from_date: Annotated[
            Optional[date],
            Field(description="filter by the from date of the report e.g. 2021-02-01"),
        ] = None,
        to_date: Annotated[
            Optional[date],
            Field(description="filter by the to date of the report e.g. 2021-02-28"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves report for aged receivables by contact  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param var_date: The date of the Aged Receivables By Contact report
        :type var_date: date
        :param from_date: filter by the from date of the report e.g. 2021-02-01
        :type from_date: date
        :param to_date: filter by the to date of the report e.g. 2021-02-28
        :type to_date: date
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "contact_id",
            "var_date",
            "from_date",
            "to_date",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_aged_receivables_by_contact" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("contact_id") is not None:  # noqa: E501
            _query_params.append(("contactId", _params["contact_id"]))

        if _params.get("var_date") is not None:  # noqa: E501
            if isinstance(_params["var_date"], date):
                _query_params.append(
                    (
                        "date",
                        _params["var_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("date", _params["var_date"]))

        if _params.get("from_date") is not None:  # noqa: E501
            if isinstance(_params["from_date"], date):
                _query_params.append(
                    (
                        "fromDate",
                        _params["from_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("fromDate", _params["from_date"]))

        if _params.get("to_date") is not None:  # noqa: E501
            if isinstance(_params["to_date"], date):
                _query_params.append(
                    (
                        "toDate",
                        _params["to_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("toDate", _params["to_date"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports/AgedReceivablesByContact",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_balance_sheet(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        var_date: Annotated[
            Optional[date], Field(description="The date of the Balance Sheet report")
        ] = None,
        periods: Annotated[
            Optional[StrictInt],
            Field(description="The number of periods for the Balance Sheet report"),
        ] = None,
        timeframe: Annotated[
            Optional[StrictStr],
            Field(description="The period size to compare to (MONTH, QUARTER, YEAR)"),
        ] = None,
        tracking_option_id1: Annotated[
            Optional[StrictStr],
            Field(description="The tracking option 1 for the Balance Sheet report"),
        ] = None,
        tracking_option_id2: Annotated[
            Optional[StrictStr],
            Field(description="The tracking option 2 for the Balance Sheet report"),
        ] = None,
        standard_layout: Annotated[
            Optional[StrictBool],
            Field(
                description="The standard layout boolean for the Balance Sheet report"
            ),
        ] = None,
        payments_only: Annotated[
            Optional[StrictBool],
            Field(description="return a cash basis for the Balance Sheet report"),
        ] = None,
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves report for balancesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param var_date: The date of the Balance Sheet report
        :type var_date: date
        :param periods: The number of periods for the Balance Sheet report
        :type periods: int
        :param timeframe: The period size to compare to (MONTH, QUARTER, YEAR)
        :type timeframe: str
        :param tracking_option_id1: The tracking option 1 for the Balance Sheet report
        :type tracking_option_id1: str
        :param tracking_option_id2: The tracking option 2 for the Balance Sheet report
        :type tracking_option_id2: str
        :param standard_layout: The standard layout boolean for the Balance Sheet report
        :type standard_layout: bool
        :param payments_only: return a cash basis for the Balance Sheet report
        :type payments_only: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_balance_sheet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_balance_sheet_with_http_info(
            xero_tenant_id,
            var_date,
            periods,
            timeframe,
            tracking_option_id1,
            tracking_option_id2,
            standard_layout,
            payments_only,
            **kwargs,
        )  # noqa: E501

    async def get_report_balance_sheet_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        var_date: Annotated[
            Optional[date], Field(description="The date of the Balance Sheet report")
        ] = None,
        periods: Annotated[
            Optional[StrictInt],
            Field(description="The number of periods for the Balance Sheet report"),
        ] = None,
        timeframe: Annotated[
            Optional[StrictStr],
            Field(description="The period size to compare to (MONTH, QUARTER, YEAR)"),
        ] = None,
        tracking_option_id1: Annotated[
            Optional[StrictStr],
            Field(description="The tracking option 1 for the Balance Sheet report"),
        ] = None,
        tracking_option_id2: Annotated[
            Optional[StrictStr],
            Field(description="The tracking option 2 for the Balance Sheet report"),
        ] = None,
        standard_layout: Annotated[
            Optional[StrictBool],
            Field(
                description="The standard layout boolean for the Balance Sheet report"
            ),
        ] = None,
        payments_only: Annotated[
            Optional[StrictBool],
            Field(description="return a cash basis for the Balance Sheet report"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves report for balancesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param var_date: The date of the Balance Sheet report
        :type var_date: date
        :param periods: The number of periods for the Balance Sheet report
        :type periods: int
        :param timeframe: The period size to compare to (MONTH, QUARTER, YEAR)
        :type timeframe: str
        :param tracking_option_id1: The tracking option 1 for the Balance Sheet report
        :type tracking_option_id1: str
        :param tracking_option_id2: The tracking option 2 for the Balance Sheet report
        :type tracking_option_id2: str
        :param standard_layout: The standard layout boolean for the Balance Sheet report
        :type standard_layout: bool
        :param payments_only: return a cash basis for the Balance Sheet report
        :type payments_only: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "var_date",
            "periods",
            "timeframe",
            "tracking_option_id1",
            "tracking_option_id2",
            "standard_layout",
            "payments_only",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_balance_sheet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("var_date") is not None:  # noqa: E501
            if isinstance(_params["var_date"], date):
                _query_params.append(
                    (
                        "date",
                        _params["var_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("date", _params["var_date"]))

        if _params.get("periods") is not None:  # noqa: E501
            _query_params.append(("periods", _params["periods"]))

        if _params.get("timeframe") is not None:  # noqa: E501
            _query_params.append(("timeframe", _params["timeframe"]))

        if _params.get("tracking_option_id1") is not None:  # noqa: E501
            _query_params.append(("trackingOptionID1", _params["tracking_option_id1"]))

        if _params.get("tracking_option_id2") is not None:  # noqa: E501
            _query_params.append(("trackingOptionID2", _params["tracking_option_id2"]))

        if _params.get("standard_layout") is not None:  # noqa: E501
            _query_params.append(("standardLayout", _params["standard_layout"]))

        if _params.get("payments_only") is not None:  # noqa: E501
            _query_params.append(("paymentsOnly", _params["payments_only"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports/BalanceSheet",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_bank_summary(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        from_date: Annotated[
            Optional[date],
            Field(description="filter by the from date of the report e.g. 2021-02-01"),
        ] = None,
        to_date: Annotated[
            Optional[date],
            Field(description="filter by the to date of the report e.g. 2021-02-28"),
        ] = None,
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves report for bank summary  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param from_date: filter by the from date of the report e.g. 2021-02-01
        :type from_date: date
        :param to_date: filter by the to date of the report e.g. 2021-02-28
        :type to_date: date
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_bank_summary_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_bank_summary_with_http_info(
            xero_tenant_id, from_date, to_date, **kwargs
        )  # noqa: E501

    async def get_report_bank_summary_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        from_date: Annotated[
            Optional[date],
            Field(description="filter by the from date of the report e.g. 2021-02-01"),
        ] = None,
        to_date: Annotated[
            Optional[date],
            Field(description="filter by the to date of the report e.g. 2021-02-28"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves report for bank summary  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param from_date: filter by the from date of the report e.g. 2021-02-01
        :type from_date: date
        :param to_date: filter by the to date of the report e.g. 2021-02-28
        :type to_date: date
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "from_date", "to_date"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_bank_summary" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("from_date") is not None:  # noqa: E501
            if isinstance(_params["from_date"], date):
                _query_params.append(
                    (
                        "fromDate",
                        _params["from_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("fromDate", _params["from_date"]))

        if _params.get("to_date") is not None:  # noqa: E501
            if isinstance(_params["to_date"], date):
                _query_params.append(
                    (
                        "toDate",
                        _params["to_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("toDate", _params["to_date"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports/BankSummary",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_budget_summary(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date for the Bank Summary report e.g. 2018-03-31"),
        ] = None,
        periods: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of periods to compare (integer between 1 and 12)"
            ),
        ] = None,
        timeframe: Annotated[
            Optional[StrictInt],
            Field(
                description="The period size to compare to (1=month, 3=quarter, 12=year)"
            ),
        ] = None,
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves report for budget summary  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param var_date: The date for the Bank Summary report e.g. 2018-03-31
        :type var_date: date
        :param periods: The number of periods to compare (integer between 1 and 12)
        :type periods: int
        :param timeframe: The period size to compare to (1=month, 3=quarter, 12=year)
        :type timeframe: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_budget_summary_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_budget_summary_with_http_info(
            xero_tenant_id, var_date, periods, timeframe, **kwargs
        )  # noqa: E501

    async def get_report_budget_summary_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date for the Bank Summary report e.g. 2018-03-31"),
        ] = None,
        periods: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of periods to compare (integer between 1 and 12)"
            ),
        ] = None,
        timeframe: Annotated[
            Optional[StrictInt],
            Field(
                description="The period size to compare to (1=month, 3=quarter, 12=year)"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves report for budget summary  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param var_date: The date for the Bank Summary report e.g. 2018-03-31
        :type var_date: date
        :param periods: The number of periods to compare (integer between 1 and 12)
        :type periods: int
        :param timeframe: The period size to compare to (1=month, 3=quarter, 12=year)
        :type timeframe: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "var_date", "periods", "timeframe"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_budget_summary" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("var_date") is not None:  # noqa: E501
            if isinstance(_params["var_date"], date):
                _query_params.append(
                    (
                        "date",
                        _params["var_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("date", _params["var_date"]))

        if _params.get("periods") is not None:  # noqa: E501
            _query_params.append(("periods", _params["periods"]))

        if _params.get("timeframe") is not None:  # noqa: E501
            _query_params.append(("timeframe", _params["timeframe"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports/BudgetSummary",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_executive_summary(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date for the Bank Summary report e.g. 2018-03-31"),
        ] = None,
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves report for executive summary  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param var_date: The date for the Bank Summary report e.g. 2018-03-31
        :type var_date: date
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_executive_summary_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_executive_summary_with_http_info(
            xero_tenant_id, var_date, **kwargs
        )  # noqa: E501

    async def get_report_executive_summary_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date for the Bank Summary report e.g. 2018-03-31"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves report for executive summary  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param var_date: The date for the Bank Summary report e.g. 2018-03-31
        :type var_date: date
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "var_date"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_executive_summary" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("var_date") is not None:  # noqa: E501
            if isinstance(_params["var_date"], date):
                _query_params.append(
                    (
                        "date",
                        _params["var_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("date", _params["var_date"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports/ExecutiveSummary",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_from_id(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        report_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Report")
        ],
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves a specific report using a unique ReportID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param report_id: Unique identifier for a Report (required)
        :type report_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_from_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_from_id_with_http_info(
            xero_tenant_id, report_id, **kwargs
        )  # noqa: E501

    async def get_report_from_id_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        report_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Report")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific report using a unique ReportID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param report_id: Unique identifier for a Report (required)
        :type report_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "report_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_from_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["report_id"] is not None:
            _path_params["ReportID"] = _params["report_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports/{ReportID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_profit_and_loss(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        from_date: Annotated[
            Optional[date],
            Field(description="filter by the from date of the report e.g. 2021-02-01"),
        ] = None,
        to_date: Annotated[
            Optional[date],
            Field(description="filter by the to date of the report e.g. 2021-02-28"),
        ] = None,
        periods: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of periods to compare (integer between 1 and 12)"
            ),
        ] = None,
        timeframe: Annotated[
            Optional[StrictStr],
            Field(description="The period size to compare to (MONTH, QUARTER, YEAR)"),
        ] = None,
        tracking_category_id: Annotated[
            Optional[StrictStr],
            Field(description="The trackingCategory 1 for the ProfitAndLoss report"),
        ] = None,
        tracking_category_id2: Annotated[
            Optional[StrictStr],
            Field(description="The trackingCategory 2 for the ProfitAndLoss report"),
        ] = None,
        tracking_option_id: Annotated[
            Optional[StrictStr],
            Field(description="The tracking option 1 for the ProfitAndLoss report"),
        ] = None,
        tracking_option_id2: Annotated[
            Optional[StrictStr],
            Field(description="The tracking option 2 for the ProfitAndLoss report"),
        ] = None,
        standard_layout: Annotated[
            Optional[StrictBool],
            Field(
                description="Return the standard layout for the ProfitAndLoss report"
            ),
        ] = None,
        payments_only: Annotated[
            Optional[StrictBool],
            Field(description="Return cash only basis for the ProfitAndLoss report"),
        ] = None,
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves report for profit and loss  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param from_date: filter by the from date of the report e.g. 2021-02-01
        :type from_date: date
        :param to_date: filter by the to date of the report e.g. 2021-02-28
        :type to_date: date
        :param periods: The number of periods to compare (integer between 1 and 12)
        :type periods: int
        :param timeframe: The period size to compare to (MONTH, QUARTER, YEAR)
        :type timeframe: str
        :param tracking_category_id: The trackingCategory 1 for the ProfitAndLoss report
        :type tracking_category_id: str
        :param tracking_category_id2: The trackingCategory 2 for the ProfitAndLoss report
        :type tracking_category_id2: str
        :param tracking_option_id: The tracking option 1 for the ProfitAndLoss report
        :type tracking_option_id: str
        :param tracking_option_id2: The tracking option 2 for the ProfitAndLoss report
        :type tracking_option_id2: str
        :param standard_layout: Return the standard layout for the ProfitAndLoss report
        :type standard_layout: bool
        :param payments_only: Return cash only basis for the ProfitAndLoss report
        :type payments_only: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_profit_and_loss_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_profit_and_loss_with_http_info(
            xero_tenant_id,
            from_date,
            to_date,
            periods,
            timeframe,
            tracking_category_id,
            tracking_category_id2,
            tracking_option_id,
            tracking_option_id2,
            standard_layout,
            payments_only,
            **kwargs,
        )  # noqa: E501

    async def get_report_profit_and_loss_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        from_date: Annotated[
            Optional[date],
            Field(description="filter by the from date of the report e.g. 2021-02-01"),
        ] = None,
        to_date: Annotated[
            Optional[date],
            Field(description="filter by the to date of the report e.g. 2021-02-28"),
        ] = None,
        periods: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of periods to compare (integer between 1 and 12)"
            ),
        ] = None,
        timeframe: Annotated[
            Optional[StrictStr],
            Field(description="The period size to compare to (MONTH, QUARTER, YEAR)"),
        ] = None,
        tracking_category_id: Annotated[
            Optional[StrictStr],
            Field(description="The trackingCategory 1 for the ProfitAndLoss report"),
        ] = None,
        tracking_category_id2: Annotated[
            Optional[StrictStr],
            Field(description="The trackingCategory 2 for the ProfitAndLoss report"),
        ] = None,
        tracking_option_id: Annotated[
            Optional[StrictStr],
            Field(description="The tracking option 1 for the ProfitAndLoss report"),
        ] = None,
        tracking_option_id2: Annotated[
            Optional[StrictStr],
            Field(description="The tracking option 2 for the ProfitAndLoss report"),
        ] = None,
        standard_layout: Annotated[
            Optional[StrictBool],
            Field(
                description="Return the standard layout for the ProfitAndLoss report"
            ),
        ] = None,
        payments_only: Annotated[
            Optional[StrictBool],
            Field(description="Return cash only basis for the ProfitAndLoss report"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves report for profit and loss  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param from_date: filter by the from date of the report e.g. 2021-02-01
        :type from_date: date
        :param to_date: filter by the to date of the report e.g. 2021-02-28
        :type to_date: date
        :param periods: The number of periods to compare (integer between 1 and 12)
        :type periods: int
        :param timeframe: The period size to compare to (MONTH, QUARTER, YEAR)
        :type timeframe: str
        :param tracking_category_id: The trackingCategory 1 for the ProfitAndLoss report
        :type tracking_category_id: str
        :param tracking_category_id2: The trackingCategory 2 for the ProfitAndLoss report
        :type tracking_category_id2: str
        :param tracking_option_id: The tracking option 1 for the ProfitAndLoss report
        :type tracking_option_id: str
        :param tracking_option_id2: The tracking option 2 for the ProfitAndLoss report
        :type tracking_option_id2: str
        :param standard_layout: Return the standard layout for the ProfitAndLoss report
        :type standard_layout: bool
        :param payments_only: Return cash only basis for the ProfitAndLoss report
        :type payments_only: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "from_date",
            "to_date",
            "periods",
            "timeframe",
            "tracking_category_id",
            "tracking_category_id2",
            "tracking_option_id",
            "tracking_option_id2",
            "standard_layout",
            "payments_only",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_profit_and_loss" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("from_date") is not None:  # noqa: E501
            if isinstance(_params["from_date"], date):
                _query_params.append(
                    (
                        "fromDate",
                        _params["from_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("fromDate", _params["from_date"]))

        if _params.get("to_date") is not None:  # noqa: E501
            if isinstance(_params["to_date"], date):
                _query_params.append(
                    (
                        "toDate",
                        _params["to_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("toDate", _params["to_date"]))

        if _params.get("periods") is not None:  # noqa: E501
            _query_params.append(("periods", _params["periods"]))

        if _params.get("timeframe") is not None:  # noqa: E501
            _query_params.append(("timeframe", _params["timeframe"]))

        if _params.get("tracking_category_id") is not None:  # noqa: E501
            _query_params.append(
                ("trackingCategoryID", _params["tracking_category_id"])
            )

        if _params.get("tracking_category_id2") is not None:  # noqa: E501
            _query_params.append(
                ("trackingCategoryID2", _params["tracking_category_id2"])
            )

        if _params.get("tracking_option_id") is not None:  # noqa: E501
            _query_params.append(("trackingOptionID", _params["tracking_option_id"]))

        if _params.get("tracking_option_id2") is not None:  # noqa: E501
            _query_params.append(("trackingOptionID2", _params["tracking_option_id2"]))

        if _params.get("standard_layout") is not None:  # noqa: E501
            _query_params.append(("standardLayout", _params["standard_layout"]))

        if _params.get("payments_only") is not None:  # noqa: E501
            _query_params.append(("paymentsOnly", _params["payments_only"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports/ProfitAndLoss",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_ten_ninety_nine(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        report_year: Annotated[
            Optional[StrictStr], Field(description="The year of the 1099 report")
        ] = None,
        **kwargs,
    ) -> Reports:  # noqa: E501
        """Retrieve reports for 1099  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param report_year: The year of the 1099 report
        :type report_year: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Reports
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_ten_ninety_nine_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_ten_ninety_nine_with_http_info(
            xero_tenant_id, report_year, **kwargs
        )  # noqa: E501

    async def get_report_ten_ninety_nine_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        report_year: Annotated[
            Optional[StrictStr], Field(description="The year of the 1099 report")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieve reports for 1099  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param report_year: The year of the 1099 report
        :type report_year: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Reports, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "report_year"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_ten_ninety_nine" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("report_year") is not None:  # noqa: E501
            _query_params.append(("reportYear", _params["report_year"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Reports",
        }

        return await self.api_client.call_api(
            "/Reports/TenNinetyNine",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_report_trial_balance(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date for the Trial Balance report e.g. 2018-03-31"),
        ] = None,
        payments_only: Annotated[
            Optional[StrictBool],
            Field(description="Return cash only basis for the Trial Balance report"),
        ] = None,
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves report for trial balance  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param var_date: The date for the Trial Balance report e.g. 2018-03-31
        :type var_date: date
        :param payments_only: Return cash only basis for the Trial Balance report
        :type payments_only: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_report_trial_balance_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_report_trial_balance_with_http_info(
            xero_tenant_id, var_date, payments_only, **kwargs
        )  # noqa: E501

    async def get_report_trial_balance_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        var_date: Annotated[
            Optional[date],
            Field(description="The date for the Trial Balance report e.g. 2018-03-31"),
        ] = None,
        payments_only: Annotated[
            Optional[StrictBool],
            Field(description="Return cash only basis for the Trial Balance report"),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves report for trial balance  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param var_date: The date for the Trial Balance report e.g. 2018-03-31
        :type var_date: date
        :param payments_only: Return cash only basis for the Trial Balance report
        :type payments_only: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "var_date", "payments_only"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_trial_balance" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("var_date") is not None:  # noqa: E501
            if isinstance(_params["var_date"], date):
                _query_params.append(
                    (
                        "date",
                        _params["var_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("date", _params["var_date"]))

        if _params.get("payments_only") is not None:  # noqa: E501
            _query_params.append(("paymentsOnly", _params["payments_only"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports/TrialBalance",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_reports_list(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ReportWithRows:  # noqa: E501
        """Retrieves a list of the organistaions unique reports that require a uuid to fetch  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReportWithRows
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_reports_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_reports_list_with_http_info(xero_tenant_id, **kwargs)  # noqa: E501

    async def get_reports_list_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a list of the organistaions unique reports that require a uuid to fetch  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reports_list" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReportWithRows",
        }

        return await self.api_client.call_api(
            "/Reports",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_tax_rate_by_tax_type(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tax_type: Annotated[StrictStr, Field(..., description="A valid TaxType code")],
        **kwargs,
    ) -> TaxRates:  # noqa: E501
        """Retrieves a specific tax rate according to given TaxType code  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tax_type: A valid TaxType code (required)
        :type tax_type: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TaxRates
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_tax_rate_by_tax_type_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_tax_rate_by_tax_type_with_http_info(
            xero_tenant_id, tax_type, **kwargs
        )  # noqa: E501

    async def get_tax_rate_by_tax_type_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tax_type: Annotated[StrictStr, Field(..., description="A valid TaxType code")],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific tax rate according to given TaxType code  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tax_type: A valid TaxType code (required)
        :type tax_type: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TaxRates, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "tax_type"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tax_rate_by_tax_type" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["tax_type"] is not None:
            _path_params["TaxType"] = _params["tax_type"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TaxRates",
        }

        return await self.api_client.call_api(
            "/TaxRates/{TaxType}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_tax_rates(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> TaxRates:  # noqa: E501
        """Retrieves tax rates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TaxRates
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_tax_rates_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_tax_rates_with_http_info(
            xero_tenant_id, where, order, **kwargs
        )  # noqa: E501

    async def get_tax_rates_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves tax rates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TaxRates, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tax_rates" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TaxRates",
        }

        return await self.api_client.call_api(
            "/TaxRates",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_tracking_categories(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        include_archived: Annotated[
            Optional[StrictBool],
            Field(
                description="e.g. includeArchived=true - Categories and options with a status of ARCHIVED will be included in the response"
            ),
        ] = None,
        **kwargs,
    ) -> TrackingCategories:  # noqa: E501
        """Retrieves tracking categories and options  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param include_archived: e.g. includeArchived=true - Categories and options with a status of ARCHIVED will be included in the response
        :type include_archived: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingCategories
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_tracking_categories_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_tracking_categories_with_http_info(
            xero_tenant_id, where, order, include_archived, **kwargs
        )  # noqa: E501

    async def get_tracking_categories_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        include_archived: Annotated[
            Optional[StrictBool],
            Field(
                description="e.g. includeArchived=true - Categories and options with a status of ARCHIVED will be included in the response"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves tracking categories and options  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param include_archived: e.g. includeArchived=true - Categories and options with a status of ARCHIVED will be included in the response
        :type include_archived: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "where", "order", "include_archived"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tracking_categories" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("include_archived") is not None:  # noqa: E501
            _query_params.append(("includeArchived", _params["include_archived"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TrackingCategories",
        }

        return await self.api_client.call_api(
            "/TrackingCategories",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_tracking_category(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        **kwargs,
    ) -> TrackingCategories:  # noqa: E501
        """Retrieves specific tracking categories and options using a unique tracking category Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingCategories
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_tracking_category_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_tracking_category_with_http_info(
            xero_tenant_id, tracking_category_id, **kwargs
        )  # noqa: E501

    async def get_tracking_category_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves specific tracking categories and options using a unique tracking category Id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "tracking_category_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tracking_category" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["tracking_category_id"] is not None:
            _path_params["TrackingCategoryID"] = _params["tracking_category_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TrackingCategories",
        }

        return await self.api_client.call_api(
            "/TrackingCategories/{TrackingCategoryID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_user(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        user_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a User")
        ],
        **kwargs,
    ) -> Users:  # noqa: E501
        """Retrieves a specific user  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param user_id: Unique identifier for a User (required)
        :type user_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Users
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_user_with_http_info(xero_tenant_id, user_id, **kwargs)  # noqa: E501

    async def get_user_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        user_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a User")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific user  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param user_id: Unique identifier for a User (required)
        :type user_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Users, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "user_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["user_id"] is not None:
            _path_params["UserID"] = _params["user_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Users",
        }

        return await self.api_client.call_api(
            "/Users/{UserID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_users(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> Users:  # noqa: E501
        """Retrieves users  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Users
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_users_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_users_with_http_info(
            xero_tenant_id, if_modified_since, where, order, **kwargs
        )  # noqa: E501

    async def get_users_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves users  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Users, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Users",
        }

        return await self.api_client.call_api(
            "/Users",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def post_setup(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        setup: Annotated[
            Setup,
            Field(
                ...,
                description="Object including an accounts array, a conversion balances array and a conversion date object in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ImportSummaryObject:  # noqa: E501
        """Sets the chart of accounts, the conversion date and conversion balances  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param setup: Object including an accounts array, a conversion balances array and a conversion date object in body of request (required)
        :type setup: Setup
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ImportSummaryObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the post_setup_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.post_setup_with_http_info(
            xero_tenant_id, setup, idempotency_key, **kwargs
        )  # noqa: E501

    async def post_setup_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        setup: Annotated[
            Setup,
            Field(
                ...,
                description="Object including an accounts array, a conversion balances array and a conversion date object in body of request",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Sets the chart of accounts, the conversion date and conversion balances  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param setup: Object including an accounts array, a conversion balances array and a conversion date object in body of request (required)
        :type setup: Setup
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ImportSummaryObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "setup", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_setup" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["setup"] is not None:
            _body_params = _params["setup"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ImportSummaryObject",
        }

        return await self.api_client.call_api(
            "/Setup",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_account(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        accounts: Annotated[
            Accounts,
            Field(..., description="Request of type Accounts array with one Account"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Accounts:  # noqa: E501
        """Updates a chart of accounts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param accounts: Request of type Accounts array with one Account (required)
        :type accounts: Accounts
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Accounts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_account_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_account_with_http_info(
            xero_tenant_id, account_id, accounts, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_account_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        accounts: Annotated[
            Accounts,
            Field(..., description="Request of type Accounts array with one Account"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a chart of accounts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param accounts: Request of type Accounts array with one Account (required)
        :type accounts: Accounts
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "account_id", "accounts", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["AccountID"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["accounts"] is not None:
            _body_params = _params["accounts"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Accounts",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Accounts/{AccountID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_account_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Updates attachment on a specific account by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_account_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_account_attachment_by_file_name_with_http_info(
            xero_tenant_id, account_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_account_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        account_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for Account object")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates attachment on a specific account by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param account_id: Unique identifier for Account object (required)
        :type account_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "account_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["AccountID"] = _params["account_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Accounts/{AccountID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_bank_transaction(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        bank_transactions: BankTransactions,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> BankTransactions:  # noqa: E501
        """Updates a single spent or received money transaction  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param bank_transactions: (required)
        :type bank_transactions: BankTransactions
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BankTransactions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_bank_transaction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_bank_transaction_with_http_info(
            xero_tenant_id,
            bank_transaction_id,
            bank_transactions,
            unitdp,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_bank_transaction_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        bank_transactions: BankTransactions,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a single spent or received money transaction  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param bank_transactions: (required)
        :type bank_transactions: BankTransactions
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BankTransactions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transaction_id",
            "bank_transactions",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bank_transaction" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transaction_id"] is not None:
            _path_params["BankTransactionID"] = _params["bank_transaction_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["bank_transactions"] is not None:
            _body_params = _params["bank_transactions"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BankTransactions",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransactions/{BankTransactionID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_bank_transaction_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Updates a specific attachment from a specific bank transaction by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_bank_transaction_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return (
            await self.update_bank_transaction_attachment_by_file_name_with_http_info(
                xero_tenant_id,
                bank_transaction_id,
                file_name,
                body,
                idempotency_key,
                **kwargs,
            )
        )  # noqa: E501

    async def update_bank_transaction_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transaction_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Xero generated unique identifier for a bank transaction",
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific attachment from a specific bank transaction by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :type bank_transaction_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transaction_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bank_transaction_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transaction_id"] is not None:
            _path_params["BankTransactionID"] = _params["bank_transaction_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransactions/{BankTransactionID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_bank_transfer_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """update_bank_transfer_attachment_by_file_name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_bank_transfer_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_bank_transfer_attachment_by_file_name_with_http_info(
            xero_tenant_id, bank_transfer_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_bank_transfer_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transfer_id: Annotated[
            StrictStr,
            Field(
                ..., description="Xero generated unique identifier for a bank transfer"
            ),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """update_bank_transfer_attachment_by_file_name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :type bank_transfer_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transfer_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bank_transfer_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["bank_transfer_id"] is not None:
            _path_params["BankTransferID"] = _params["bank_transfer_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransfers/{BankTransferID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_contact(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        contacts: Annotated[
            Contacts,
            Field(
                ...,
                description="an array of Contacts containing single Contact object with properties to update",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Contacts:  # noqa: E501
        """Updates a specific contact in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param contacts: an array of Contacts containing single Contact object with properties to update (required)
        :type contacts: Contacts
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Contacts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_contact_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_contact_with_http_info(
            xero_tenant_id, contact_id, contacts, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_contact_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        contacts: Annotated[
            Contacts,
            Field(
                ...,
                description="an array of Contacts containing single Contact object with properties to update",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific contact in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param contacts: an array of Contacts containing single Contact object with properties to update (required)
        :type contacts: Contacts
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "contact_id", "contacts", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["contacts"] is not None:
            _body_params = _params["contacts"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Contacts",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_contact_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """update_contact_attachment_by_file_name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_contact_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_contact_attachment_by_file_name_with_http_info(
            xero_tenant_id, contact_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_contact_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """update_contact_attachment_by_file_name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_id: Unique identifier for a Contact (required)
        :type contact_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "contact_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_id"] is not None:
            _path_params["ContactID"] = _params["contact_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Contacts/{ContactID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_contact_group(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        contact_groups: Annotated[
            ContactGroups,
            Field(
                ...,
                description="an array of Contact groups with Name of specific group to update",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ContactGroups:  # noqa: E501
        """Updates a specific contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param contact_groups: an array of Contact groups with Name of specific group to update (required)
        :type contact_groups: ContactGroups
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContactGroups
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_contact_group_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_contact_group_with_http_info(
            xero_tenant_id, contact_group_id, contact_groups, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_contact_group_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contact_group_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Contact Group")
        ],
        contact_groups: Annotated[
            ContactGroups,
            Field(
                ...,
                description="an array of Contact groups with Name of specific group to update",
            ),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific contact group  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contact_group_id: Unique identifier for a Contact Group (required)
        :type contact_group_id: str
        :param contact_groups: an array of Contact groups with Name of specific group to update (required)
        :type contact_groups: ContactGroups
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ContactGroups, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "contact_group_id",
            "contact_groups",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact_group" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["contact_group_id"] is not None:
            _path_params["ContactGroupID"] = _params["contact_group_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["contact_groups"] is not None:
            _body_params = _params["contact_groups"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ContactGroups",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ContactGroups/{ContactGroupID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_credit_note(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        credit_notes: Annotated[
            CreditNotes,
            Field(
                ...,
                description="an array of Credit Notes containing credit note details to update",
            ),
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> CreditNotes:  # noqa: E501
        """Updates a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param credit_notes: an array of Credit Notes containing credit note details to update (required)
        :type credit_notes: CreditNotes
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreditNotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_credit_note_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_credit_note_with_http_info(
            xero_tenant_id,
            credit_note_id,
            credit_notes,
            unitdp,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_credit_note_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        credit_notes: Annotated[
            CreditNotes,
            Field(
                ...,
                description="an array of Credit Notes containing credit note details to update",
            ),
        ],
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific credit note  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param credit_notes: an array of Credit Notes containing credit note details to update (required)
        :type credit_notes: CreditNotes
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreditNotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "credit_note_id",
            "credit_notes",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_credit_note" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["credit_notes"] is not None:
            _body_params = _params["credit_notes"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "CreditNotes",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_credit_note_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Updates attachments on a specific credit note by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_credit_note_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_credit_note_attachment_by_file_name_with_http_info(
            xero_tenant_id, credit_note_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_credit_note_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_note_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Credit Note")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates attachments on a specific credit note by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_note_id: Unique identifier for a Credit Note (required)
        :type credit_note_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "credit_note_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_credit_note_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["credit_note_id"] is not None:
            _path_params["CreditNoteID"] = _params["credit_note_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/CreditNotes/{CreditNoteID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_expense_claim(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claim_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ExpenseClaim")
        ],
        expense_claims: ExpenseClaims,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ExpenseClaims:  # noqa: E501
        """Updates a specific expense claims  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :type expense_claim_id: str
        :param expense_claims: (required)
        :type expense_claims: ExpenseClaims
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExpenseClaims
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_expense_claim_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_expense_claim_with_http_info(
            xero_tenant_id, expense_claim_id, expense_claims, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_expense_claim_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        expense_claim_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ExpenseClaim")
        ],
        expense_claims: ExpenseClaims,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific expense claims  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :type expense_claim_id: str
        :param expense_claims: (required)
        :type expense_claims: ExpenseClaims
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExpenseClaims, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "expense_claim_id",
            "expense_claims",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_expense_claim" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["expense_claim_id"] is not None:
            _path_params["ExpenseClaimID"] = _params["expense_claim_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["expense_claims"] is not None:
            _body_params = _params["expense_claims"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ExpenseClaims",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ExpenseClaims/{ExpenseClaimID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_invoice(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        invoices: Invoices,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Invoices:  # noqa: E501
        """Updates a specific sales invoices or purchase bills  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param invoices: (required)
        :type invoices: Invoices
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Invoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_invoice_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_invoice_with_http_info(
            xero_tenant_id, invoice_id, invoices, unitdp, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_invoice_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        invoices: Invoices,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific sales invoices or purchase bills  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param invoices: (required)
        :type invoices: Invoices
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Invoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "invoice_id",
            "invoices",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_invoice" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["invoices"] is not None:
            _body_params = _params["invoices"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Invoices",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_invoice_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Updates an attachment from a specific invoices or purchase bill by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_invoice_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_invoice_attachment_by_file_name_with_http_info(
            xero_tenant_id, invoice_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_invoice_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoice_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Invoice")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates an attachment from a specific invoices or purchase bill by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoice_id: Unique identifier for an Invoice (required)
        :type invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "invoice_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_invoice_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["invoice_id"] is not None:
            _path_params["InvoiceID"] = _params["invoice_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Invoices/{InvoiceID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_item(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        items: Items,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Items:  # noqa: E501
        """Updates a specific item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param items: (required)
        :type items: Items
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Items
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_item_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_item_with_http_info(
            xero_tenant_id, item_id, items, unitdp, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_item_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        item_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Item")
        ],
        items: Items,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param item_id: Unique identifier for an Item (required)
        :type item_id: str
        :param items: (required)
        :type items: Items
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Items, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "item_id",
            "items",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_item" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["item_id"] is not None:
            _path_params["ItemID"] = _params["item_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["items"] is not None:
            _body_params = _params["items"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Items",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Items/{ItemID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_linked_transaction(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        linked_transaction_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a LinkedTransaction"),
        ],
        linked_transactions: LinkedTransactions,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> LinkedTransactions:  # noqa: E501
        """Updates a specific linked transactions (billable expenses)  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :type linked_transaction_id: str
        :param linked_transactions: (required)
        :type linked_transactions: LinkedTransactions
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LinkedTransactions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_linked_transaction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_linked_transaction_with_http_info(
            xero_tenant_id,
            linked_transaction_id,
            linked_transactions,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_linked_transaction_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        linked_transaction_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a LinkedTransaction"),
        ],
        linked_transactions: LinkedTransactions,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific linked transactions (billable expenses)  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :type linked_transaction_id: str
        :param linked_transactions: (required)
        :type linked_transactions: LinkedTransactions
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LinkedTransactions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "linked_transaction_id",
            "linked_transactions",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_linked_transaction" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["linked_transaction_id"] is not None:
            _path_params["LinkedTransactionID"] = _params["linked_transaction_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["linked_transactions"] is not None:
            _body_params = _params["linked_transactions"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LinkedTransactions",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/LinkedTransactions/{LinkedTransactionID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_manual_journal(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        manual_journals: ManualJournals,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ManualJournals:  # noqa: E501
        """Updates a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param manual_journals: (required)
        :type manual_journals: ManualJournals
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ManualJournals
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_manual_journal_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_manual_journal_with_http_info(
            xero_tenant_id,
            manual_journal_id,
            manual_journals,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_manual_journal_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        manual_journals: ManualJournals,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param manual_journals: (required)
        :type manual_journals: ManualJournals
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ManualJournals, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "manual_journal_id",
            "manual_journals",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_manual_journal" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["manual_journal_id"] is not None:
            _path_params["ManualJournalID"] = _params["manual_journal_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["manual_journals"] is not None:
            _body_params = _params["manual_journals"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ManualJournals",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ManualJournals/{ManualJournalID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_manual_journal_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Updates a specific attachment from a specific manual journal by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_manual_journal_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_manual_journal_attachment_by_file_name_with_http_info(
            xero_tenant_id,
            manual_journal_id,
            file_name,
            body,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_manual_journal_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journal_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a ManualJournal")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific attachment from a specific manual journal by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journal_id: Unique identifier for a ManualJournal (required)
        :type manual_journal_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "manual_journal_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_manual_journal_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["manual_journal_id"] is not None:
            _path_params["ManualJournalID"] = _params["manual_journal_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ManualJournals/{ManualJournalID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_bank_transactions(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transactions: BankTransactions,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> BankTransactions:  # noqa: E501
        """Updates or creates one or more spent or received money transaction  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transactions: (required)
        :type bank_transactions: BankTransactions
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BankTransactions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_bank_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_bank_transactions_with_http_info(
            xero_tenant_id,
            bank_transactions,
            summarize_errors,
            unitdp,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_or_create_bank_transactions_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        bank_transactions: BankTransactions,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates or creates one or more spent or received money transaction  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param bank_transactions: (required)
        :type bank_transactions: BankTransactions
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BankTransactions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "bank_transactions",
            "summarize_errors",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_bank_transactions" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["bank_transactions"] is not None:
            _body_params = _params["bank_transactions"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "BankTransactions",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/BankTransactions",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_contacts(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contacts: Contacts,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Contacts:  # noqa: E501
        """Updates or creates one or more contacts in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contacts: (required)
        :type contacts: Contacts
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Contacts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_contacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_contacts_with_http_info(
            xero_tenant_id, contacts, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_or_create_contacts_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        contacts: Contacts,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates or creates one or more contacts in a Xero organisation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param contacts: (required)
        :type contacts: Contacts
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "contacts",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_contacts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["contacts"] is not None:
            _body_params = _params["contacts"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Contacts",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Contacts",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_credit_notes(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_notes: Annotated[
            CreditNotes,
            Field(
                ...,
                description="an array of Credit Notes with a single CreditNote object.",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> CreditNotes:  # noqa: E501
        """Updates or creates one or more credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_notes: an array of Credit Notes with a single CreditNote object. (required)
        :type credit_notes: CreditNotes
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreditNotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_credit_notes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_credit_notes_with_http_info(
            xero_tenant_id,
            credit_notes,
            summarize_errors,
            unitdp,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_or_create_credit_notes_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        credit_notes: Annotated[
            CreditNotes,
            Field(
                ...,
                description="an array of Credit Notes with a single CreditNote object.",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates or creates one or more credit notes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param credit_notes: an array of Credit Notes with a single CreditNote object. (required)
        :type credit_notes: CreditNotes
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreditNotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "credit_notes",
            "summarize_errors",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_credit_notes" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["credit_notes"] is not None:
            _body_params = _params["credit_notes"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "CreditNotes",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/CreditNotes",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_employees(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employees: Annotated[
            Employees,
            Field(
                ...,
                description="Employees with array of Employee object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Employees:  # noqa: E501
        """Creates a single new employees used in Xero payrun  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employees: Employees with array of Employee object in body of request (required)
        :type employees: Employees
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Employees
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_employees_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_employees_with_http_info(
            xero_tenant_id, employees, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_or_create_employees_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employees: Annotated[
            Employees,
            Field(
                ...,
                description="Employees with array of Employee object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a single new employees used in Xero payrun  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employees: Employees with array of Employee object in body of request (required)
        :type employees: Employees
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employees",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_employees" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employees"] is not None:
            _body_params = _params["employees"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Employees",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Employees",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_invoices(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoices: Invoices,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Invoices:  # noqa: E501
        """Updates or creates one or more sales invoices or purchase bills  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoices: (required)
        :type invoices: Invoices
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Invoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_invoices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_invoices_with_http_info(
            xero_tenant_id,
            invoices,
            summarize_errors,
            unitdp,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_or_create_invoices_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        invoices: Invoices,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates or creates one or more sales invoices or purchase bills  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param invoices: (required)
        :type invoices: Invoices
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Invoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "invoices",
            "summarize_errors",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_invoices" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["invoices"] is not None:
            _body_params = _params["invoices"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Invoices",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Invoices",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_items(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        items: Items,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Items:  # noqa: E501
        """Updates or creates one or more items  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param items: (required)
        :type items: Items
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Items
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_items_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_items_with_http_info(
            xero_tenant_id, items, summarize_errors, unitdp, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_or_create_items_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        items: Items,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates or creates one or more items  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param items: (required)
        :type items: Items
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Items, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "items",
            "summarize_errors",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_items" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["items"] is not None:
            _body_params = _params["items"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Items",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Items",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_manual_journals(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journals: Annotated[
            ManualJournals,
            Field(
                ...,
                description="ManualJournals array with ManualJournal object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ManualJournals:  # noqa: E501
        """Updates or creates a single manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journals: ManualJournals array with ManualJournal object in body of request (required)
        :type manual_journals: ManualJournals
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ManualJournals
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_manual_journals_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_manual_journals_with_http_info(
            xero_tenant_id, manual_journals, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_or_create_manual_journals_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        manual_journals: Annotated[
            ManualJournals,
            Field(
                ...,
                description="ManualJournals array with ManualJournal object in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates or creates a single manual journal  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param manual_journals: ManualJournals array with ManualJournal object in body of request (required)
        :type manual_journals: ManualJournals
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ManualJournals, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "manual_journals",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_manual_journals" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["manual_journals"] is not None:
            _body_params = _params["manual_journals"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ManualJournals",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/ManualJournals",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_purchase_orders(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_orders: PurchaseOrders,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PurchaseOrders:  # noqa: E501
        """Updates or creates one or more purchase orders  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_orders: (required)
        :type purchase_orders: PurchaseOrders
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PurchaseOrders
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_purchase_orders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_purchase_orders_with_http_info(
            xero_tenant_id, purchase_orders, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_or_create_purchase_orders_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_orders: PurchaseOrders,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates or creates one or more purchase orders  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_orders: (required)
        :type purchase_orders: PurchaseOrders
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "purchase_orders",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_purchase_orders" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["purchase_orders"] is not None:
            _body_params = _params["purchase_orders"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PurchaseOrders",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_quotes(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quotes: Quotes,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Quotes:  # noqa: E501
        """Updates or creates one or more quotes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quotes: (required)
        :type quotes: Quotes
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Quotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_quotes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_quotes_with_http_info(
            xero_tenant_id, quotes, summarize_errors, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_or_create_quotes_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quotes: Quotes,
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates or creates one or more quotes  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quotes: (required)
        :type quotes: Quotes
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Quotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "quotes",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_quotes" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["quotes"] is not None:
            _body_params = _params["quotes"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Quotes",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Quotes",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_or_create_repeating_invoices(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoices: Annotated[
            RepeatingInvoices,
            Field(
                ...,
                description="RepeatingInvoices with an array of repeating invoice objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> RepeatingInvoices:  # noqa: E501
        """Creates or deletes one or more repeating invoice templates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoices: RepeatingInvoices with an array of repeating invoice objects in body of request (required)
        :type repeating_invoices: RepeatingInvoices
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RepeatingInvoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_or_create_repeating_invoices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_or_create_repeating_invoices_with_http_info(
            xero_tenant_id,
            repeating_invoices,
            summarize_errors,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_or_create_repeating_invoices_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoices: Annotated[
            RepeatingInvoices,
            Field(
                ...,
                description="RepeatingInvoices with an array of repeating invoice objects in body of request",
            ),
        ],
        summarize_errors: Annotated[
            Optional[StrictBool],
            Field(
                description="If false return 200 OK and mix of successfully created objects and any with validation errors"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates or deletes one or more repeating invoice templates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoices: RepeatingInvoices with an array of repeating invoice objects in body of request (required)
        :type repeating_invoices: RepeatingInvoices
        :param summarize_errors: If false return 200 OK and mix of successfully created objects and any with validation errors
        :type summarize_errors: bool
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RepeatingInvoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "repeating_invoices",
            "summarize_errors",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_or_create_repeating_invoices" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("summarize_errors") is not None:  # noqa: E501
            _query_params.append(("summarizeErrors", _params["summarize_errors"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["repeating_invoices"] is not None:
            _body_params = _params["repeating_invoices"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "RepeatingInvoices",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_purchase_order(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        purchase_orders: PurchaseOrders,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PurchaseOrders:  # noqa: E501
        """Updates a specific purchase order  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param purchase_orders: (required)
        :type purchase_orders: PurchaseOrders
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PurchaseOrders
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_purchase_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_purchase_order_with_http_info(
            xero_tenant_id,
            purchase_order_id,
            purchase_orders,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_purchase_order_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        purchase_orders: PurchaseOrders,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific purchase order  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param purchase_orders: (required)
        :type purchase_orders: PurchaseOrders
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "purchase_order_id",
            "purchase_orders",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_purchase_order" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["purchase_orders"] is not None:
            _body_params = _params["purchase_orders"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PurchaseOrders",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_purchase_order_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Updates a specific attachment for a specific purchase order by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_purchase_order_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_purchase_order_attachment_by_file_name_with_http_info(
            xero_tenant_id,
            purchase_order_id,
            file_name,
            body,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_purchase_order_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        purchase_order_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Purchase Order")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific attachment for a specific purchase order by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param purchase_order_id: Unique identifier for an Purchase Order (required)
        :type purchase_order_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "purchase_order_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_purchase_order_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["purchase_order_id"] is not None:
            _path_params["PurchaseOrderID"] = _params["purchase_order_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_quote(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        quotes: Quotes,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Quotes:  # noqa: E501
        """Updates a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param quotes: (required)
        :type quotes: Quotes
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Quotes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_quote_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_quote_with_http_info(
            xero_tenant_id, quote_id, quotes, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_quote_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        quotes: Quotes,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific quote  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param quotes: (required)
        :type quotes: Quotes
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Quotes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "quote_id", "quotes", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_quote" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["quotes"] is not None:
            _body_params = _params["quotes"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Quotes",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_quote_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Updates a specific attachment from a specific quote by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_quote_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_quote_attachment_by_file_name_with_http_info(
            xero_tenant_id, quote_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_quote_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        quote_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for an Quote")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific attachment from a specific quote by filename  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param quote_id: Unique identifier for an Quote (required)
        :type quote_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "quote_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_quote_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["quote_id"] is not None:
            _path_params["QuoteID"] = _params["quote_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Quotes/{QuoteID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_receipt(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        receipts: Receipts,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Receipts:  # noqa: E501
        """Updates a specific draft expense claim receipts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param receipts: (required)
        :type receipts: Receipts
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Receipts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_receipt_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_receipt_with_http_info(
            xero_tenant_id, receipt_id, receipts, unitdp, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_receipt_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        receipts: Receipts,
        unitdp: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts"
            ),
        ] = None,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific draft expense claim receipts  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param receipts: (required)
        :type receipts: Receipts
        :param unitdp: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
        :type unitdp: int
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Receipts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "receipt_id",
            "receipts",
            "unitdp",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_receipt" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["receipt_id"] is not None:
            _path_params["ReceiptID"] = _params["receipt_id"]

        # process the query parameters
        _query_params = []
        if _params.get("unitdp") is not None:  # noqa: E501
            _query_params.append(("unitdp", _params["unitdp"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["receipts"] is not None:
            _body_params = _params["receipts"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Receipts",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Receipts/{ReceiptID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_receipt_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Updates a specific attachment on a specific expense claim receipts by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_receipt_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_receipt_attachment_by_file_name_with_http_info(
            xero_tenant_id, receipt_id, file_name, body, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_receipt_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        receipt_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Receipt")
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific attachment on a specific expense claim receipts by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param receipt_id: Unique identifier for a Receipt (required)
        :type receipt_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "receipt_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_receipt_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["receipt_id"] is not None:
            _path_params["ReceiptID"] = _params["receipt_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/Receipts/{ReceiptID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_repeating_invoice(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        repeating_invoices: RepeatingInvoices,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> RepeatingInvoices:  # noqa: E501
        """Deletes a specific repeating invoice template  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param repeating_invoices: (required)
        :type repeating_invoices: RepeatingInvoices
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RepeatingInvoices
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_repeating_invoice_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_repeating_invoice_with_http_info(
            xero_tenant_id,
            repeating_invoice_id,
            repeating_invoices,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_repeating_invoice_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        repeating_invoices: RepeatingInvoices,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a specific repeating invoice template  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param repeating_invoices: (required)
        :type repeating_invoices: RepeatingInvoices
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RepeatingInvoices, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "repeating_invoice_id",
            "repeating_invoices",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_repeating_invoice" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["repeating_invoice_id"] is not None:
            _path_params["RepeatingInvoiceID"] = _params["repeating_invoice_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["repeating_invoices"] is not None:
            _body_params = _params["repeating_invoices"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "RepeatingInvoices",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices/{RepeatingInvoiceID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_repeating_invoice_attachment_by_file_name(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Attachments:  # noqa: E501
        """Updates a specific attachment from a specific repeating invoices by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachments
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_repeating_invoice_attachment_by_file_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return (
            await self.update_repeating_invoice_attachment_by_file_name_with_http_info(
                xero_tenant_id,
                repeating_invoice_id,
                file_name,
                body,
                idempotency_key,
                **kwargs,
            )
        )  # noqa: E501

    async def update_repeating_invoice_attachment_by_file_name_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        repeating_invoice_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a Repeating Invoice"),
        ],
        file_name: Annotated[
            StrictStr, Field(..., description="Name of the attachment")
        ],
        body: Annotated[
            Union[StrictBytes, StrictStr],
            Field(..., description="Byte array of file in body of request"),
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific attachment from a specific repeating invoices by file name  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :type repeating_invoice_id: str
        :param file_name: Name of the attachment (required)
        :type file_name: str
        :param body: Byte array of file in body of request (required)
        :type body: bytearray
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "repeating_invoice_id",
            "file_name",
            "body",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_repeating_invoice_attachment_by_file_name" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["repeating_invoice_id"] is not None:
            _path_params["RepeatingInvoiceID"] = _params["repeating_invoice_id"]

        if _params["file_name"] is not None:
            _path_params["FileName"] = _params["file_name"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]
            # convert to byte array if the input is a file name (str)
            if isinstance(_body_params, str):
                with io.open(_body_params, "rb") as _fp:
                    _body_params_from_file = _fp.read()
                _body_params = _body_params_from_file

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Attachments",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_tax_rate(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tax_rates: TaxRates,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TaxRates:  # noqa: E501
        """Updates tax rates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tax_rates: (required)
        :type tax_rates: TaxRates
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TaxRates
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_tax_rate_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_tax_rate_with_http_info(
            xero_tenant_id, tax_rates, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_tax_rate_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tax_rates: TaxRates,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates tax rates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tax_rates: (required)
        :type tax_rates: TaxRates
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TaxRates, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "tax_rates", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tax_rate" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["tax_rates"] is not None:
            _body_params = _params["tax_rates"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TaxRates",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/TaxRates",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_tracking_category(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        tracking_category: TrackingCategory,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TrackingCategories:  # noqa: E501
        """Updates a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param tracking_category: (required)
        :type tracking_category: TrackingCategory
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingCategories
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_tracking_category_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_tracking_category_with_http_info(
            xero_tenant_id,
            tracking_category_id,
            tracking_category,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_tracking_category_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        tracking_category: TrackingCategory,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param tracking_category: (required)
        :type tracking_category: TrackingCategory
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "tracking_category_id",
            "tracking_category",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tracking_category" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["tracking_category_id"] is not None:
            _path_params["TrackingCategoryID"] = _params["tracking_category_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["tracking_category"] is not None:
            _body_params = _params["tracking_category"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TrackingCategories",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/TrackingCategories/{TrackingCategoryID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_tracking_options(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        tracking_option_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Tracking Option")
        ],
        tracking_option: TrackingOption,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TrackingOptions:  # noqa: E501
        """Updates a specific option for a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param tracking_option_id: Unique identifier for a Tracking Option (required)
        :type tracking_option_id: str
        :param tracking_option: (required)
        :type tracking_option: TrackingOption
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingOptions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_tracking_options_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_tracking_options_with_http_info(
            xero_tenant_id,
            tracking_category_id,
            tracking_option_id,
            tracking_option,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_tracking_options_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        tracking_category_id: Annotated[
            StrictStr,
            Field(..., description="Unique identifier for a TrackingCategory"),
        ],
        tracking_option_id: Annotated[
            StrictStr, Field(..., description="Unique identifier for a Tracking Option")
        ],
        tracking_option: TrackingOption,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific option for a specific tracking category  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param tracking_category_id: Unique identifier for a TrackingCategory (required)
        :type tracking_category_id: str
        :param tracking_option_id: Unique identifier for a Tracking Option (required)
        :type tracking_option_id: str
        :param tracking_option: (required)
        :type tracking_option: TrackingOption
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingOptions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "tracking_category_id",
            "tracking_option_id",
            "tracking_option",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tracking_options" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["tracking_category_id"] is not None:
            _path_params["TrackingCategoryID"] = _params["tracking_category_id"]

        if _params["tracking_option_id"] is not None:
            _path_params["TrackingOptionID"] = _params["tracking_option_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["xero-tenant-id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["tracking_option"] is not None:
            _body_params = _params["tracking_option"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TrackingOptions",
            "400": "Error",
        }

        return await self.api_client.call_api(
            "/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
