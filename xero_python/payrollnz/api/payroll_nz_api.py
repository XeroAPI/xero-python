"""
    Xero Payroll NZ

    This is the Xero Payroll API for orgs in the NZ region.

    The version of the OpenAPI document: 6.3.0
    Contact: api@xero.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import importlib
import re  # noqa: F401
from datetime import date
from typing import Optional

from pydantic import (
    Field,
    StrictBool,
    StrictInt,
    StrictStr,
    conlist,
)
from typing_extensions import Annotated

from xero_python.api_client import ApiClient, ApiResponse, ModelFinder
from xero_python.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError,
)
from xero_python.payrollnz.models.benefit import Benefit
from xero_python.payrollnz.models.deduction import Deduction
from xero_python.payrollnz.models.deduction_object import DeductionObject
from xero_python.payrollnz.models.deductions import Deductions
from xero_python.payrollnz.models.earnings_rate import EarningsRate
from xero_python.payrollnz.models.earnings_rate_object import EarningsRateObject
from xero_python.payrollnz.models.earnings_rates import EarningsRates
from xero_python.payrollnz.models.earnings_template import EarningsTemplate
from xero_python.payrollnz.models.earnings_template_object import EarningsTemplateObject
from xero_python.payrollnz.models.employee import Employee
from xero_python.payrollnz.models.employee_earnings_templates import (
    EmployeeEarningsTemplates,
)
from xero_python.payrollnz.models.employee_leave import EmployeeLeave
from xero_python.payrollnz.models.employee_leave_balances import EmployeeLeaveBalances
from xero_python.payrollnz.models.employee_leave_object import EmployeeLeaveObject
from xero_python.payrollnz.models.employee_leave_setup import EmployeeLeaveSetup
from xero_python.payrollnz.models.employee_leave_setup_object import (
    EmployeeLeaveSetupObject,
)
from xero_python.payrollnz.models.employee_leave_type import EmployeeLeaveType
from xero_python.payrollnz.models.employee_leave_type_object import (
    EmployeeLeaveTypeObject,
)
from xero_python.payrollnz.models.employee_leave_types import EmployeeLeaveTypes
from xero_python.payrollnz.models.employee_leaves import EmployeeLeaves
from xero_python.payrollnz.models.employee_object import EmployeeObject
from xero_python.payrollnz.models.employee_opening_balance import EmployeeOpeningBalance
from xero_python.payrollnz.models.employee_opening_balances_object import (
    EmployeeOpeningBalancesObject,
)
from xero_python.payrollnz.models.employee_pay_templates import EmployeePayTemplates
from xero_python.payrollnz.models.employee_tax import EmployeeTax
from xero_python.payrollnz.models.employee_tax_object import EmployeeTaxObject
from xero_python.payrollnz.models.employee_working_pattern_with_working_weeks_object import (
    EmployeeWorkingPatternWithWorkingWeeksObject,
)
from xero_python.payrollnz.models.employee_working_pattern_with_working_weeks_request import (
    EmployeeWorkingPatternWithWorkingWeeksRequest,
)
from xero_python.payrollnz.models.employee_working_patterns_object import (
    EmployeeWorkingPatternsObject,
)
from xero_python.payrollnz.models.employees import Employees
from xero_python.payrollnz.models.employment import Employment
from xero_python.payrollnz.models.employment_object import EmploymentObject
from xero_python.payrollnz.models.leave_periods import LeavePeriods
from xero_python.payrollnz.models.leave_type import LeaveType
from xero_python.payrollnz.models.leave_type_object import LeaveTypeObject
from xero_python.payrollnz.models.leave_types import LeaveTypes
from xero_python.payrollnz.models.pay_run import PayRun
from xero_python.payrollnz.models.pay_run_calendar import PayRunCalendar
from xero_python.payrollnz.models.pay_run_calendar_object import PayRunCalendarObject
from xero_python.payrollnz.models.pay_run_calendars import PayRunCalendars
from xero_python.payrollnz.models.pay_run_object import PayRunObject
from xero_python.payrollnz.models.pay_runs import PayRuns
from xero_python.payrollnz.models.pay_slip import PaySlip
from xero_python.payrollnz.models.pay_slip_object import PaySlipObject
from xero_python.payrollnz.models.pay_slips import PaySlips
from xero_python.payrollnz.models.payment_method import PaymentMethod
from xero_python.payrollnz.models.payment_method_object import PaymentMethodObject
from xero_python.payrollnz.models.reimbursement import Reimbursement
from xero_python.payrollnz.models.reimbursement_object import ReimbursementObject
from xero_python.payrollnz.models.reimbursements import Reimbursements
from xero_python.payrollnz.models.salary_and_wage import SalaryAndWage
from xero_python.payrollnz.models.salary_and_wage_object import SalaryAndWageObject
from xero_python.payrollnz.models.salary_and_wages import SalaryAndWages
from xero_python.payrollnz.models.settings import Settings
from xero_python.payrollnz.models.statutory_deduction_object import (
    StatutoryDeductionObject,
)
from xero_python.payrollnz.models.statutory_deductions import StatutoryDeductions
from xero_python.payrollnz.models.superannuation_object import SuperannuationObject
from xero_python.payrollnz.models.superannuations import Superannuations
from xero_python.payrollnz.models.timesheet import Timesheet
from xero_python.payrollnz.models.timesheet_line import TimesheetLine
from xero_python.payrollnz.models.timesheet_line_object import TimesheetLineObject
from xero_python.payrollnz.models.timesheet_object import TimesheetObject
from xero_python.payrollnz.models.timesheets import Timesheets
from xero_python.payrollnz.models.tracking_categories import TrackingCategories


class PayrollNzApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    base_url = "https://api.xero.com/payroll.xro/2.0"
    models_module = importlib.import_module("xero_python.payrollnz.models")

    def __init__(self, api_client=None, base_url: str | None = None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client
        self.base_url = base_url or self.base_url

    def get_model_finder(self):
        return ModelFinder(self.models_module)

    async def approve_timesheet(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TimesheetObject:  # noqa: E501
        """Approves a timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TimesheetObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the approve_timesheet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.approve_timesheet_with_http_info(
            xero_tenant_id, timesheet_id, idempotency_key, **kwargs
        )  # noqa: E501

    async def approve_timesheet_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Approves a timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TimesheetObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "timesheet_id", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method approve_timesheet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["timesheet_id"] is not None:
            _path_params["TimesheetID"] = _params["timesheet_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TimesheetObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Timesheets/{TimesheetID}/Approve",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_deduction(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        deduction: Deduction,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> DeductionObject:  # noqa: E501
        """Creates a new deduction for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param deduction: (required)
        :type deduction: Deduction
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeductionObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_deduction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_deduction_with_http_info(
            xero_tenant_id, deduction, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_deduction_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        deduction: Deduction,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new deduction for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param deduction: (required)
        :type deduction: Deduction
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeductionObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "deduction", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_deduction" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["deduction"] is not None:
            _body_params = _params["deduction"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "DeductionObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Deductions",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_earnings_rate(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        earnings_rate: EarningsRate,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EarningsRateObject:  # noqa: E501
        """Creates a new earnings rate  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param earnings_rate: (required)
        :type earnings_rate: EarningsRate
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EarningsRateObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_earnings_rate_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_earnings_rate_with_http_info(
            xero_tenant_id, earnings_rate, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_earnings_rate_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        earnings_rate: EarningsRate,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new earnings rate  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param earnings_rate: (required)
        :type earnings_rate: EarningsRate
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EarningsRateObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "earnings_rate", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_earnings_rate" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["earnings_rate"] is not None:
            _body_params = _params["earnings_rate"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EarningsRateObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/EarningsRates",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee: Employee,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeObject:  # noqa: E501
        """Creates an employees  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee: (required)
        :type employee: Employee
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_with_http_info(
            xero_tenant_id, employee, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employee_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee: Employee,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an employees  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee: (required)
        :type employee: Employee
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee"] is not None:
            _body_params = _params["employee"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee_earnings_template(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        earnings_template: EarningsTemplate,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EarningsTemplateObject:  # noqa: E501
        """Creates earnings template records for an employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param earnings_template: (required)
        :type earnings_template: EarningsTemplate
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EarningsTemplateObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_earnings_template_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_earnings_template_with_http_info(
            xero_tenant_id, employee_id, earnings_template, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employee_earnings_template_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        earnings_template: EarningsTemplate,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates earnings template records for an employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param earnings_template: (required)
        :type earnings_template: EarningsTemplate
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EarningsTemplateObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "earnings_template",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee_earnings_template" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["earnings_template"] is not None:
            _body_params = _params["earnings_template"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EarningsTemplateObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/PayTemplates/Earnings",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee_leave(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_leave: EmployeeLeave,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeLeaveObject:  # noqa: E501
        """Creates leave records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_leave: (required)
        :type employee_leave: EmployeeLeave
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeLeaveObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_leave_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_leave_with_http_info(
            xero_tenant_id, employee_id, employee_leave, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employee_leave_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_leave: EmployeeLeave,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates leave records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_leave: (required)
        :type employee_leave: EmployeeLeave
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeLeaveObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "employee_leave",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee_leave" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee_leave"] is not None:
            _body_params = _params["employee_leave"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeLeaveObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Leave",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee_leave_setup(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_leave_setup: EmployeeLeaveSetup,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeLeaveSetupObject:  # noqa: E501
        """Creates a leave set-up for a specific employee. This is required before viewing, configuring and requesting leave for an employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_leave_setup: (required)
        :type employee_leave_setup: EmployeeLeaveSetup
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeLeaveSetupObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_leave_setup_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_leave_setup_with_http_info(
            xero_tenant_id, employee_id, employee_leave_setup, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employee_leave_setup_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_leave_setup: EmployeeLeaveSetup,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a leave set-up for a specific employee. This is required before viewing, configuring and requesting leave for an employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_leave_setup: (required)
        :type employee_leave_setup: EmployeeLeaveSetup
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeLeaveSetupObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "employee_leave_setup",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee_leave_setup" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee_leave_setup"] is not None:
            _body_params = _params["employee_leave_setup"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeLeaveSetupObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/LeaveSetup",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee_leave_type(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_leave_type: EmployeeLeaveType,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeLeaveTypeObject:  # noqa: E501
        """Creates leave type records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_leave_type: (required)
        :type employee_leave_type: EmployeeLeaveType
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeLeaveTypeObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_leave_type_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_leave_type_with_http_info(
            xero_tenant_id, employee_id, employee_leave_type, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employee_leave_type_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_leave_type: EmployeeLeaveType,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates leave type records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_leave_type: (required)
        :type employee_leave_type: EmployeeLeaveType
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeLeaveTypeObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "employee_leave_type",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee_leave_type" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee_leave_type"] is not None:
            _body_params = _params["employee_leave_type"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeLeaveTypeObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/LeaveTypes",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee_opening_balances(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_opening_balance: conlist(EmployeeOpeningBalance),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeOpeningBalancesObject:  # noqa: E501
        """Creates opening balances for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_opening_balance: (required)
        :type employee_opening_balance: List[EmployeeOpeningBalance]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeOpeningBalancesObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_opening_balances_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_opening_balances_with_http_info(
            xero_tenant_id,
            employee_id,
            employee_opening_balance,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_employee_opening_balances_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_opening_balance: conlist(EmployeeOpeningBalance),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates opening balances for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_opening_balance: (required)
        :type employee_opening_balance: List[EmployeeOpeningBalance]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeOpeningBalancesObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "employee_opening_balance",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee_opening_balances" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee_opening_balance"] is not None:
            _body_params = _params["employee_opening_balance"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeOpeningBalancesObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/OpeningBalances",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee_payment_method(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        payment_method: PaymentMethod,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PaymentMethodObject:  # noqa: E501
        """Creates a payment method for an employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param payment_method: (required)
        :type payment_method: PaymentMethod
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaymentMethodObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_payment_method_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_payment_method_with_http_info(
            xero_tenant_id, employee_id, payment_method, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employee_payment_method_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        payment_method: PaymentMethod,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a payment method for an employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param payment_method: (required)
        :type payment_method: PaymentMethod
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaymentMethodObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "payment_method",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee_payment_method" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["payment_method"] is not None:
            _body_params = _params["payment_method"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PaymentMethodObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/PaymentMethods",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee_salary_and_wage(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        salary_and_wage: SalaryAndWage,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> SalaryAndWageObject:  # noqa: E501
        """Creates an employee salary and wage record  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param salary_and_wage: (required)
        :type salary_and_wage: SalaryAndWage
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SalaryAndWageObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_salary_and_wage_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_salary_and_wage_with_http_info(
            xero_tenant_id, employee_id, salary_and_wage, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employee_salary_and_wage_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        salary_and_wage: SalaryAndWage,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an employee salary and wage record  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param salary_and_wage: (required)
        :type salary_and_wage: SalaryAndWage
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SalaryAndWageObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "salary_and_wage",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee_salary_and_wage" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["salary_and_wage"] is not None:
            _body_params = _params["salary_and_wage"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SalaryAndWageObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/SalaryAndWages",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee_working_pattern(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_working_pattern_with_working_weeks_request: EmployeeWorkingPatternWithWorkingWeeksRequest,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeWorkingPatternWithWorkingWeeksObject:  # noqa: E501
        """Creates an employee working pattern  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_working_pattern_with_working_weeks_request: (required)
        :type employee_working_pattern_with_working_weeks_request: EmployeeWorkingPatternWithWorkingWeeksRequest
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeWorkingPatternWithWorkingWeeksObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_working_pattern_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_working_pattern_with_http_info(
            xero_tenant_id,
            employee_id,
            employee_working_pattern_with_working_weeks_request,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def create_employee_working_pattern_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_working_pattern_with_working_weeks_request: EmployeeWorkingPatternWithWorkingWeeksRequest,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an employee working pattern  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_working_pattern_with_working_weeks_request: (required)
        :type employee_working_pattern_with_working_weeks_request: EmployeeWorkingPatternWithWorkingWeeksRequest
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeWorkingPatternWithWorkingWeeksObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "employee_working_pattern_with_working_weeks_request",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee_working_pattern" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee_working_pattern_with_working_weeks_request"] is not None:
            _body_params = _params[
                "employee_working_pattern_with_working_weeks_request"
            ]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeWorkingPatternWithWorkingWeeksObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Working-Patterns",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employment(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employment: Employment,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmploymentObject:  # noqa: E501
        """Creates an employment detail for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employment: (required)
        :type employment: Employment
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmploymentObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employment_with_http_info(
            xero_tenant_id, employee_id, employment, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employment_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employment: Employment,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an employment detail for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employment: (required)
        :type employment: Employment
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmploymentObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "employment", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employment" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employment"] is not None:
            _body_params = _params["employment"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmploymentObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Employment",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_leave_type(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_type: LeaveType,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> LeaveTypeObject:  # noqa: E501
        """Creates a new leave type  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_type: (required)
        :type leave_type: LeaveType
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveTypeObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_leave_type_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_leave_type_with_http_info(
            xero_tenant_id, leave_type, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_leave_type_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_type: LeaveType,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new leave type  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_type: (required)
        :type leave_type: LeaveType
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveTypeObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "leave_type", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_leave_type" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["leave_type"] is not None:
            _body_params = _params["leave_type"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveTypeObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/LeaveTypes",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_multiple_employee_earnings_template(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        earnings_template: conlist(EarningsTemplate),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeEarningsTemplates:  # noqa: E501
        """Creates multiple employee earnings template records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param earnings_template: (required)
        :type earnings_template: List[EarningsTemplate]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeEarningsTemplates
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_multiple_employee_earnings_template_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_multiple_employee_earnings_template_with_http_info(
            xero_tenant_id, employee_id, earnings_template, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_multiple_employee_earnings_template_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        earnings_template: conlist(EarningsTemplate),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates multiple employee earnings template records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param earnings_template: (required)
        :type earnings_template: List[EarningsTemplate]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeEarningsTemplates, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "earnings_template",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_multiple_employee_earnings_template" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["earnings_template"] is not None:
            _body_params = _params["earnings_template"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeEarningsTemplates",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/PayTemplateEarnings",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_pay_run(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run: PayRun,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PayRunObject:  # noqa: E501
        """Creates a pay run  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run: (required)
        :type pay_run: PayRun
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRunObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_pay_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_pay_run_with_http_info(
            xero_tenant_id, pay_run, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_pay_run_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run: PayRun,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a pay run  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run: (required)
        :type pay_run: PayRun
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRunObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_run", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pay_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["pay_run"] is not None:
            _body_params = _params["pay_run"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRunObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/PayRuns",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_pay_run_calendar(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_calendar: PayRunCalendar,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PayRunCalendarObject:  # noqa: E501
        """Creates a new payrun calendar  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_calendar: (required)
        :type pay_run_calendar: PayRunCalendar
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRunCalendarObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_pay_run_calendar_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_pay_run_calendar_with_http_info(
            xero_tenant_id, pay_run_calendar, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_pay_run_calendar_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_calendar: PayRunCalendar,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new payrun calendar  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_calendar: (required)
        :type pay_run_calendar: PayRunCalendar
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRunCalendarObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_run_calendar", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pay_run_calendar" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["pay_run_calendar"] is not None:
            _body_params = _params["pay_run_calendar"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRunCalendarObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/PayRunCalendars",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_reimbursement(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        reimbursement: Reimbursement,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ReimbursementObject:  # noqa: E501
        """Creates a new reimbursement  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param reimbursement: (required)
        :type reimbursement: Reimbursement
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReimbursementObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_reimbursement_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_reimbursement_with_http_info(
            xero_tenant_id, reimbursement, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_reimbursement_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        reimbursement: Reimbursement,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new reimbursement  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param reimbursement: (required)
        :type reimbursement: Reimbursement
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReimbursementObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "reimbursement", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_reimbursement" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["reimbursement"] is not None:
            _body_params = _params["reimbursement"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReimbursementObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Reimbursements",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_superannuation(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        benefit: Benefit,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> SuperannuationObject:  # noqa: E501
        """Creates a new superannuation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param benefit: (required)
        :type benefit: Benefit
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuperannuationObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_superannuation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_superannuation_with_http_info(
            xero_tenant_id, benefit, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_superannuation_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        benefit: Benefit,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new superannuation  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param benefit: (required)
        :type benefit: Benefit
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuperannuationObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "benefit", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_superannuation" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["benefit"] is not None:
            _body_params = _params["benefit"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SuperannuationObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Superannuations",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_timesheet(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet: Timesheet,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TimesheetObject:  # noqa: E501
        """Creates a new timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet: (required)
        :type timesheet: Timesheet
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TimesheetObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_timesheet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_timesheet_with_http_info(
            xero_tenant_id, timesheet, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_timesheet_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet: Timesheet,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a new timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet: (required)
        :type timesheet: Timesheet
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TimesheetObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "timesheet", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_timesheet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["timesheet"] is not None:
            _body_params = _params["timesheet"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TimesheetObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Timesheets",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_timesheet_line(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        timesheet_line: TimesheetLine,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TimesheetLineObject:  # noqa: E501
        """Create a new timesheet line for a specific time sheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param timesheet_line: (required)
        :type timesheet_line: TimesheetLine
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TimesheetLineObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_timesheet_line_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_timesheet_line_with_http_info(
            xero_tenant_id, timesheet_id, timesheet_line, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_timesheet_line_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        timesheet_line: TimesheetLine,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Create a new timesheet line for a specific time sheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param timesheet_line: (required)
        :type timesheet_line: TimesheetLine
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TimesheetLineObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "timesheet_id",
            "timesheet_line",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_timesheet_line" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["timesheet_id"] is not None:
            _path_params["TimesheetID"] = _params["timesheet_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["timesheet_line"] is not None:
            _body_params = _params["timesheet_line"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TimesheetLineObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Timesheets/{TimesheetID}/Lines",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_employee_earnings_template(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        pay_template_earning_id: Annotated[
            StrictStr,
            Field(..., description="Id for single pay template earnings object"),
        ],
        **kwargs,
    ) -> EarningsTemplateObject:  # noqa: E501
        """Deletes an employee's earnings template record  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param pay_template_earning_id: Id for single pay template earnings object (required)
        :type pay_template_earning_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EarningsTemplateObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_employee_earnings_template_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_employee_earnings_template_with_http_info(
            xero_tenant_id, employee_id, pay_template_earning_id, **kwargs
        )  # noqa: E501

    async def delete_employee_earnings_template_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        pay_template_earning_id: Annotated[
            StrictStr,
            Field(..., description="Id for single pay template earnings object"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes an employee's earnings template record  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param pay_template_earning_id: Id for single pay template earnings object (required)
        :type pay_template_earning_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EarningsTemplateObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "pay_template_earning_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_employee_earnings_template" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        if _params["pay_template_earning_id"] is not None:
            _path_params["PayTemplateEarningID"] = _params["pay_template_earning_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EarningsTemplateObject",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/PayTemplates/Earnings/{PayTemplateEarningID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_employee_leave(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        leave_id: Annotated[
            StrictStr, Field(..., description="Leave id for single object")
        ],
        **kwargs,
    ) -> EmployeeLeaveObject:  # noqa: E501
        """Deletes a leave record for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param leave_id: Leave id for single object (required)
        :type leave_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeLeaveObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_employee_leave_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_employee_leave_with_http_info(
            xero_tenant_id, employee_id, leave_id, **kwargs
        )  # noqa: E501

    async def delete_employee_leave_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        leave_id: Annotated[
            StrictStr, Field(..., description="Leave id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a leave record for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param leave_id: Leave id for single object (required)
        :type leave_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeLeaveObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "leave_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_employee_leave" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        if _params["leave_id"] is not None:
            _path_params["LeaveID"] = _params["leave_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeLeaveObject",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Leave/{LeaveID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_employee_salary_and_wage(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        salary_and_wages_id: Annotated[
            StrictStr, Field(..., description="Id for single salary and wages object")
        ],
        **kwargs,
    ) -> SalaryAndWageObject:  # noqa: E501
        """Deletes an employee's salary and wages record  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param salary_and_wages_id: Id for single salary and wages object (required)
        :type salary_and_wages_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SalaryAndWageObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_employee_salary_and_wage_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_employee_salary_and_wage_with_http_info(
            xero_tenant_id, employee_id, salary_and_wages_id, **kwargs
        )  # noqa: E501

    async def delete_employee_salary_and_wage_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        salary_and_wages_id: Annotated[
            StrictStr, Field(..., description="Id for single salary and wages object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes an employee's salary and wages record  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param salary_and_wages_id: Id for single salary and wages object (required)
        :type salary_and_wages_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SalaryAndWageObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "salary_and_wages_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_employee_salary_and_wage" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        if _params["salary_and_wages_id"] is not None:
            _path_params["SalaryAndWagesID"] = _params["salary_and_wages_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SalaryAndWageObject",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/SalaryAndWages/{SalaryAndWagesID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_employee_working_pattern(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_working_pattern_id: Annotated[
            StrictStr,
            Field(..., description="Employee working pattern id for single object"),
        ],
        **kwargs,
    ) -> EmployeeLeaveObject:  # noqa: E501
        """deletes employee's working patterns  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_working_pattern_id: Employee working pattern id for single object (required)
        :type employee_working_pattern_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeLeaveObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_employee_working_pattern_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_employee_working_pattern_with_http_info(
            xero_tenant_id, employee_id, employee_working_pattern_id, **kwargs
        )  # noqa: E501

    async def delete_employee_working_pattern_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_working_pattern_id: Annotated[
            StrictStr,
            Field(..., description="Employee working pattern id for single object"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """deletes employee's working patterns  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_working_pattern_id: Employee working pattern id for single object (required)
        :type employee_working_pattern_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeLeaveObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "employee_working_pattern_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_employee_working_pattern" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        if _params["employee_working_pattern_id"] is not None:
            _path_params["EmployeeWorkingPatternID"] = _params[
                "employee_working_pattern_id"
            ]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeLeaveObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Working-Patterns/{EmployeeWorkingPatternID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_timesheet(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        **kwargs,
    ) -> TimesheetLine:  # noqa: E501
        """Deletes a timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TimesheetLine
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_timesheet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_timesheet_with_http_info(
            xero_tenant_id, timesheet_id, **kwargs
        )  # noqa: E501

    async def delete_timesheet_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TimesheetLine, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "timesheet_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_timesheet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["timesheet_id"] is not None:
            _path_params["TimesheetID"] = _params["timesheet_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TimesheetLine",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Timesheets/{TimesheetID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def delete_timesheet_line(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        timesheet_line_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet line")
        ],
        **kwargs,
    ) -> TimesheetLine:  # noqa: E501
        """Deletes a timesheet line for a specific timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param timesheet_line_id: Identifier for the timesheet line (required)
        :type timesheet_line_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TimesheetLine
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_timesheet_line_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.delete_timesheet_line_with_http_info(
            xero_tenant_id, timesheet_id, timesheet_line_id, **kwargs
        )  # noqa: E501

    async def delete_timesheet_line_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        timesheet_line_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet line")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Deletes a timesheet line for a specific timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param timesheet_line_id: Identifier for the timesheet line (required)
        :type timesheet_line_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TimesheetLine, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "timesheet_id", "timesheet_line_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_timesheet_line" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["timesheet_id"] is not None:
            _path_params["TimesheetID"] = _params["timesheet_id"]

        if _params["timesheet_line_id"] is not None:
            _path_params["TimesheetLineID"] = _params["timesheet_line_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TimesheetLine",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Timesheets/{TimesheetID}/Lines/{TimesheetLineID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_deduction(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        deduction_id: Annotated[
            StrictStr, Field(..., description="Identifier for the deduction")
        ],
        **kwargs,
    ) -> DeductionObject:  # noqa: E501
        """Retrieves a single deduction by using a unique deduction ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param deduction_id: Identifier for the deduction (required)
        :type deduction_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeductionObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_deduction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_deduction_with_http_info(
            xero_tenant_id, deduction_id, **kwargs
        )  # noqa: E501

    async def get_deduction_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        deduction_id: Annotated[
            StrictStr, Field(..., description="Identifier for the deduction")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a single deduction by using a unique deduction ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param deduction_id: Identifier for the deduction (required)
        :type deduction_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeductionObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "deduction_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_deduction" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["deduction_id"] is not None:
            _path_params["deductionId"] = _params["deduction_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "DeductionObject",
        }

        return await self.api_client.call_api(
            "/Deductions/{deductionId}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_deductions(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> Deductions:  # noqa: E501
        """Retrieves deductions for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Deductions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_deductions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_deductions_with_http_info(xero_tenant_id, page, **kwargs)  # noqa: E501

    async def get_deductions_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves deductions for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Deductions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_deductions" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Deductions",
        }

        return await self.api_client.call_api(
            "/Deductions",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_earnings_rate(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        earnings_rate_id: Annotated[
            StrictStr, Field(..., description="Identifier for the earnings rate")
        ],
        **kwargs,
    ) -> EarningsRateObject:  # noqa: E501
        """Retrieves a specific earnings rates by using a unique earnings rate id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param earnings_rate_id: Identifier for the earnings rate (required)
        :type earnings_rate_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EarningsRateObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_earnings_rate_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_earnings_rate_with_http_info(
            xero_tenant_id, earnings_rate_id, **kwargs
        )  # noqa: E501

    async def get_earnings_rate_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        earnings_rate_id: Annotated[
            StrictStr, Field(..., description="Identifier for the earnings rate")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific earnings rates by using a unique earnings rate id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param earnings_rate_id: Identifier for the earnings rate (required)
        :type earnings_rate_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EarningsRateObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "earnings_rate_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_earnings_rate" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["earnings_rate_id"] is not None:
            _path_params["EarningsRateID"] = _params["earnings_rate_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EarningsRateObject",
        }

        return await self.api_client.call_api(
            "/EarningsRates/{EarningsRateID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_earnings_rates(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> EarningsRates:  # noqa: E501
        """Retrieves earnings rates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EarningsRates
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_earnings_rates_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_earnings_rates_with_http_info(
            xero_tenant_id, page, **kwargs
        )  # noqa: E501

    async def get_earnings_rates_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves earnings rates  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EarningsRates, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_earnings_rates" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EarningsRates",
        }

        return await self.api_client.call_api(
            "/EarningsRates",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> EmployeeObject:  # noqa: E501
        """Retrieves an employees using a unique employee ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves an employees using a unique employee ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeObject",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_leave_balances(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> EmployeeLeaveBalances:  # noqa: E501
        """Retrieves leave balances for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeLeaveBalances
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_leave_balances_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_leave_balances_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_leave_balances_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves leave balances for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeLeaveBalances, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_leave_balances" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeLeaveBalances",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/LeaveBalances",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_leave_periods(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        start_date: Annotated[
            Optional[date], Field(description="Filter by start date")
        ] = None,
        end_date: Annotated[
            Optional[date], Field(description="Filter by end date")
        ] = None,
        **kwargs,
    ) -> LeavePeriods:  # noqa: E501
        """Retrieves leave periods for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param start_date: Filter by start date
        :type start_date: date
        :param end_date: Filter by end date
        :type end_date: date
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeavePeriods
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_leave_periods_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_leave_periods_with_http_info(
            xero_tenant_id, employee_id, start_date, end_date, **kwargs
        )  # noqa: E501

    async def get_employee_leave_periods_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        start_date: Annotated[
            Optional[date], Field(description="Filter by start date")
        ] = None,
        end_date: Annotated[
            Optional[date], Field(description="Filter by end date")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves leave periods for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param start_date: Filter by start date
        :type start_date: date
        :param end_date: Filter by end date
        :type end_date: date
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeavePeriods, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "start_date", "end_date"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_leave_periods" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        if _params.get("start_date") is not None:  # noqa: E501
            if isinstance(_params["start_date"], date):
                _query_params.append(
                    (
                        "startDate",
                        _params["start_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("startDate", _params["start_date"]))

        if _params.get("end_date") is not None:  # noqa: E501
            if isinstance(_params["end_date"], date):
                _query_params.append(
                    (
                        "endDate",
                        _params["end_date"].strftime(
                            self.api_client.configuration.date_format
                        ),
                    )
                )
            else:
                _query_params.append(("endDate", _params["end_date"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeavePeriods",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/LeavePeriods",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_leave_types(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> EmployeeLeaveTypes:  # noqa: E501
        """Retrieves leave types for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeLeaveTypes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_leave_types_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_leave_types_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_leave_types_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves leave types for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeLeaveTypes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_leave_types" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeLeaveTypes",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/LeaveTypes",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_leaves(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> EmployeeLeaves:  # noqa: E501
        """Retrieves leave records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeLeaves
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_leaves_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_leaves_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_leaves_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves leave records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeLeaves, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_leaves" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeLeaves",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Leave",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_opening_balances(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> EmployeeOpeningBalancesObject:  # noqa: E501
        """Retrieves the opening balance for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeOpeningBalancesObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_opening_balances_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_opening_balances_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_opening_balances_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves the opening balance for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeOpeningBalancesObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_opening_balances" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeOpeningBalancesObject",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/OpeningBalances",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_pay_templates(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> EmployeePayTemplates:  # noqa: E501
        """Retrieves pay templates for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeePayTemplates
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_pay_templates_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_pay_templates_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_pay_templates_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves pay templates for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeePayTemplates, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_pay_templates" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeePayTemplates",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/PayTemplates",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_payment_method(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> PaymentMethodObject:  # noqa: E501
        """Retrieves available payment methods for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaymentMethodObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_payment_method_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_payment_method_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_payment_method_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves available payment methods for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaymentMethodObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_payment_method" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PaymentMethodObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/PaymentMethods",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_salary_and_wage(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        salary_and_wages_id: Annotated[
            StrictStr,
            Field(..., description="Id for single pay template earnings object"),
        ],
        **kwargs,
    ) -> SalaryAndWages:  # noqa: E501
        """Retrieves an employee's salary and wages record by using a unique salary and wage ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param salary_and_wages_id: Id for single pay template earnings object (required)
        :type salary_and_wages_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SalaryAndWages
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_salary_and_wage_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_salary_and_wage_with_http_info(
            xero_tenant_id, employee_id, salary_and_wages_id, **kwargs
        )  # noqa: E501

    async def get_employee_salary_and_wage_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        salary_and_wages_id: Annotated[
            StrictStr,
            Field(..., description="Id for single pay template earnings object"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves an employee's salary and wages record by using a unique salary and wage ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param salary_and_wages_id: Id for single pay template earnings object (required)
        :type salary_and_wages_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SalaryAndWages, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "salary_and_wages_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_salary_and_wage" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        if _params["salary_and_wages_id"] is not None:
            _path_params["SalaryAndWagesID"] = _params["salary_and_wages_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SalaryAndWages",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/SalaryAndWages/{SalaryAndWagesID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_salary_and_wages(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> SalaryAndWages:  # noqa: E501
        """Retrieves an employee's salary and wages  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SalaryAndWages
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_salary_and_wages_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_salary_and_wages_with_http_info(
            xero_tenant_id, employee_id, page, **kwargs
        )  # noqa: E501

    async def get_employee_salary_and_wages_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves an employee's salary and wages  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SalaryAndWages, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_salary_and_wages" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SalaryAndWages",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/SalaryAndWages",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_tax(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> EmployeeTaxObject:  # noqa: E501
        """Retrieves tax records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeTaxObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_tax_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_tax_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_tax_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves tax records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeTaxObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_tax" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeTaxObject",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Tax",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_working_pattern(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_working_pattern_id: Annotated[
            StrictStr,
            Field(..., description="Employee working pattern id for single object"),
        ],
        **kwargs,
    ) -> EmployeeWorkingPatternWithWorkingWeeksObject:  # noqa: E501
        """Retrieves employee's working patterns  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_working_pattern_id: Employee working pattern id for single object (required)
        :type employee_working_pattern_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeWorkingPatternWithWorkingWeeksObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_working_pattern_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_working_pattern_with_http_info(
            xero_tenant_id, employee_id, employee_working_pattern_id, **kwargs
        )  # noqa: E501

    async def get_employee_working_pattern_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_working_pattern_id: Annotated[
            StrictStr,
            Field(..., description="Employee working pattern id for single object"),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves employee's working patterns  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_working_pattern_id: Employee working pattern id for single object (required)
        :type employee_working_pattern_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeWorkingPatternWithWorkingWeeksObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "employee_working_pattern_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_working_pattern" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        if _params["employee_working_pattern_id"] is not None:
            _path_params["EmployeeWorkingPatternID"] = _params[
                "employee_working_pattern_id"
            ]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeWorkingPatternWithWorkingWeeksObject",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Working-Patterns/{EmployeeWorkingPatternID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee_working_patterns(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> EmployeeWorkingPatternsObject:  # noqa: E501
        """Retrieves employee's working patterns  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeWorkingPatternsObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_working_patterns_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_working_patterns_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_working_patterns_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves employee's working patterns  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeWorkingPatternsObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee_working_patterns" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeWorkingPatternsObject",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Working-Patterns",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employees(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        filter: Annotated[
            Optional[StrictStr],
            Field(description="Filter by first name and/or lastname"),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> Employees:  # noqa: E501
        """Retrieves employees  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param filter: Filter by first name and/or lastname
        :type filter: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Employees
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employees_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employees_with_http_info(
            xero_tenant_id, filter, page, **kwargs
        )  # noqa: E501

    async def get_employees_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        filter: Annotated[
            Optional[StrictStr],
            Field(description="Filter by first name and/or lastname"),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves employees  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param filter: Filter by first name and/or lastname
        :type filter: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "filter", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employees" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("filter") is not None:  # noqa: E501
            _query_params.append(("filter", _params["filter"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Employees",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_leave_type(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_type_id: Annotated[
            StrictStr, Field(..., description="Identifier for the leave type")
        ],
        **kwargs,
    ) -> LeaveTypeObject:  # noqa: E501
        """Retrieves a specific leave type by using a unique leave type ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_type_id: Identifier for the leave type (required)
        :type leave_type_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveTypeObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_leave_type_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_leave_type_with_http_info(
            xero_tenant_id, leave_type_id, **kwargs
        )  # noqa: E501

    async def get_leave_type_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_type_id: Annotated[
            StrictStr, Field(..., description="Identifier for the leave type")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific leave type by using a unique leave type ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_type_id: Identifier for the leave type (required)
        :type leave_type_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveTypeObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "leave_type_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_leave_type" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["leave_type_id"] is not None:
            _path_params["LeaveTypeID"] = _params["leave_type_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveTypeObject",
        }

        return await self.api_client.call_api(
            "/LeaveTypes/{LeaveTypeID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_leave_types(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        active_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Filters leave types by active status. By default the API returns all leave types."
            ),
        ] = None,
        **kwargs,
    ) -> LeaveTypes:  # noqa: E501
        """Retrieves leave types  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param active_only: Filters leave types by active status. By default the API returns all leave types.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveTypes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_leave_types_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_leave_types_with_http_info(
            xero_tenant_id, page, active_only, **kwargs
        )  # noqa: E501

    async def get_leave_types_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        active_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Filters leave types by active status. By default the API returns all leave types."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves leave types  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param active_only: Filters leave types by active status. By default the API returns all leave types.
        :type active_only: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveTypes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "page", "active_only"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_leave_types" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("active_only") is not None:  # noqa: E501
            _query_params.append(("ActiveOnly", _params["active_only"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveTypes",
        }

        return await self.api_client.call_api(
            "/LeaveTypes",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_pay_run(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr, Field(..., description="Identifier for the pay run")
        ],
        **kwargs,
    ) -> PayRunObject:  # noqa: E501
        """Retrieves a specific pay run by using a unique pay run ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: Identifier for the pay run (required)
        :type pay_run_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRunObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_pay_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_pay_run_with_http_info(
            xero_tenant_id, pay_run_id, **kwargs
        )  # noqa: E501

    async def get_pay_run_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr, Field(..., description="Identifier for the pay run")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific pay run by using a unique pay run ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: Identifier for the pay run (required)
        :type pay_run_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRunObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_run_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pay_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["pay_run_id"] is not None:
            _path_params["PayRunID"] = _params["pay_run_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRunObject",
        }

        return await self.api_client.call_api(
            "/PayRuns/{PayRunID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_pay_run_calendar(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payroll_calendar_id: Annotated[
            StrictStr, Field(..., description="Identifier for the payrun calendars")
        ],
        **kwargs,
    ) -> PayRunCalendarObject:  # noqa: E501
        """Retrieves a specific payrun calendar by using a unique payroll calendar ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payroll_calendar_id: Identifier for the payrun calendars (required)
        :type payroll_calendar_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRunCalendarObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_pay_run_calendar_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_pay_run_calendar_with_http_info(
            xero_tenant_id, payroll_calendar_id, **kwargs
        )  # noqa: E501

    async def get_pay_run_calendar_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payroll_calendar_id: Annotated[
            StrictStr, Field(..., description="Identifier for the payrun calendars")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific payrun calendar by using a unique payroll calendar ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payroll_calendar_id: Identifier for the payrun calendars (required)
        :type payroll_calendar_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRunCalendarObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "payroll_calendar_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pay_run_calendar" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["payroll_calendar_id"] is not None:
            _path_params["PayrollCalendarID"] = _params["payroll_calendar_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRunCalendarObject",
        }

        return await self.api_client.call_api(
            "/PayRunCalendars/{PayrollCalendarID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_pay_run_calendars(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> PayRunCalendars:  # noqa: E501
        """Retrieves payrun calendars  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRunCalendars
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_pay_run_calendars_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_pay_run_calendars_with_http_info(
            xero_tenant_id, page, **kwargs
        )  # noqa: E501

    async def get_pay_run_calendars_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves payrun calendars  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRunCalendars, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pay_run_calendars" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRunCalendars",
        }

        return await self.api_client.call_api(
            "/PayRunCalendars",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_pay_runs(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        status: Annotated[
            Optional[StrictStr],
            Field(
                description="By default get payruns will return all the payruns for an organization. You can add GET https://api.xero.com/payroll.xro/2.0/payRuns?statu={PayRunStatus} to filter the payruns by status."
            ),
        ] = None,
        **kwargs,
    ) -> PayRuns:  # noqa: E501
        """Retrieves pay runs  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param status: By default get payruns will return all the payruns for an organization. You can add GET https://api.xero.com/payroll.xro/2.0/payRuns?statu={PayRunStatus} to filter the payruns by status.
        :type status: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRuns
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_pay_runs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_pay_runs_with_http_info(
            xero_tenant_id, page, status, **kwargs
        )  # noqa: E501

    async def get_pay_runs_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        status: Annotated[
            Optional[StrictStr],
            Field(
                description="By default get payruns will return all the payruns for an organization. You can add GET https://api.xero.com/payroll.xro/2.0/payRuns?statu={PayRunStatus} to filter the payruns by status."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves pay runs  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param status: By default get payruns will return all the payruns for an organization. You can add GET https://api.xero.com/payroll.xro/2.0/payRuns?statu={PayRunStatus} to filter the payruns by status.
        :type status: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRuns, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "page", "status"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pay_runs" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("status") is not None:  # noqa: E501
            _query_params.append(("status", _params["status"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRuns",
        }

        return await self.api_client.call_api(
            "/PayRuns",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_pay_slip(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_slip_id: Annotated[
            StrictStr, Field(..., description="Identifier for the payslip")
        ],
        **kwargs,
    ) -> PaySlipObject:  # noqa: E501
        """Retrieves a specific payslip by a unique pay slip ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_slip_id: Identifier for the payslip (required)
        :type pay_slip_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaySlipObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_pay_slip_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_pay_slip_with_http_info(
            xero_tenant_id, pay_slip_id, **kwargs
        )  # noqa: E501

    async def get_pay_slip_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_slip_id: Annotated[
            StrictStr, Field(..., description="Identifier for the payslip")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific payslip by a unique pay slip ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_slip_id: Identifier for the payslip (required)
        :type pay_slip_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaySlipObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_slip_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pay_slip" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["pay_slip_id"] is not None:
            _path_params["PaySlipID"] = _params["pay_slip_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PaySlipObject",
        }

        return await self.api_client.call_api(
            "/PaySlips/{PaySlipID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_pay_slips(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="PayrunID which specifies the containing payrun of payslips to retrieve. By default, the API does not group payslips by payrun.",
            ),
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> PaySlips:  # noqa: E501
        """Retrieves payslips  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: PayrunID which specifies the containing payrun of payslips to retrieve. By default, the API does not group payslips by payrun. (required)
        :type pay_run_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaySlips
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_pay_slips_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_pay_slips_with_http_info(
            xero_tenant_id, pay_run_id, page, **kwargs
        )  # noqa: E501

    async def get_pay_slips_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="PayrunID which specifies the containing payrun of payslips to retrieve. By default, the API does not group payslips by payrun.",
            ),
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves payslips  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: PayrunID which specifies the containing payrun of payslips to retrieve. By default, the API does not group payslips by payrun. (required)
        :type pay_run_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaySlips, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_run_id", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pay_slips" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("pay_run_id") is not None:  # noqa: E501
            _query_params.append(("PayRunID", _params["pay_run_id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PaySlips",
        }

        return await self.api_client.call_api(
            "/PaySlips",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_reimbursement(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        reimbursement_id: Annotated[
            StrictStr, Field(..., description="Identifier for the reimbursement")
        ],
        **kwargs,
    ) -> ReimbursementObject:  # noqa: E501
        """Retrieves a specific reimbursement by using a unique reimbursement ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param reimbursement_id: Identifier for the reimbursement (required)
        :type reimbursement_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReimbursementObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_reimbursement_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_reimbursement_with_http_info(
            xero_tenant_id, reimbursement_id, **kwargs
        )  # noqa: E501

    async def get_reimbursement_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        reimbursement_id: Annotated[
            StrictStr, Field(..., description="Identifier for the reimbursement")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific reimbursement by using a unique reimbursement ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param reimbursement_id: Identifier for the reimbursement (required)
        :type reimbursement_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReimbursementObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "reimbursement_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reimbursement" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["reimbursement_id"] is not None:
            _path_params["ReimbursementID"] = _params["reimbursement_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "ReimbursementObject",
        }

        return await self.api_client.call_api(
            "/Reimbursements/{ReimbursementID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_reimbursements(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> Reimbursements:  # noqa: E501
        """Retrieves reimbursements  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Reimbursements
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_reimbursements_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_reimbursements_with_http_info(
            xero_tenant_id, page, **kwargs
        )  # noqa: E501

    async def get_reimbursements_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves reimbursements  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Reimbursements, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reimbursements" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Reimbursements",
        }

        return await self.api_client.call_api(
            "/Reimbursements",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_settings(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> Settings:  # noqa: E501
        """Retrieves settings  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Settings
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_settings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_settings_with_http_info(xero_tenant_id, **kwargs)  # noqa: E501

    async def get_settings_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves settings  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Settings, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_settings" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Settings",
        }

        return await self.api_client.call_api(
            "/Settings",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_statutory_deduction(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        id: Annotated[
            StrictStr, Field(..., description="Identifier for the statutory deduction")
        ],
        **kwargs,
    ) -> StatutoryDeductionObject:  # noqa: E501
        """Retrieves a specific statutory deduction by using a unique statutory deductions id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param id: Identifier for the statutory deduction (required)
        :type id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StatutoryDeductionObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_statutory_deduction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_statutory_deduction_with_http_info(
            xero_tenant_id, id, **kwargs
        )  # noqa: E501

    async def get_statutory_deduction_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        id: Annotated[
            StrictStr, Field(..., description="Identifier for the statutory deduction")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific statutory deduction by using a unique statutory deductions id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param id: Identifier for the statutory deduction (required)
        :type id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StatutoryDeductionObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_statutory_deduction" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["id"] is not None:
            _path_params["id"] = _params["id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "StatutoryDeductionObject",
        }

        return await self.api_client.call_api(
            "/StatutoryDeductions/{id}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_statutory_deductions(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> StatutoryDeductions:  # noqa: E501
        """Retrieves statutory deductions  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StatutoryDeductions
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_statutory_deductions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_statutory_deductions_with_http_info(
            xero_tenant_id, page, **kwargs
        )  # noqa: E501

    async def get_statutory_deductions_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves statutory deductions  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StatutoryDeductions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_statutory_deductions" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "StatutoryDeductions",
        }

        return await self.api_client.call_api(
            "/StatutoryDeductions",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_superannuation(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        superannuation_id: Annotated[
            StrictStr, Field(..., description="Identifier for the superannuation")
        ],
        **kwargs,
    ) -> SuperannuationObject:  # noqa: E501
        """Retrieves a specific superannuation using a unique superannuation ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param superannuation_id: Identifier for the superannuation (required)
        :type superannuation_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuperannuationObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_superannuation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_superannuation_with_http_info(
            xero_tenant_id, superannuation_id, **kwargs
        )  # noqa: E501

    async def get_superannuation_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        superannuation_id: Annotated[
            StrictStr, Field(..., description="Identifier for the superannuation")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific superannuation using a unique superannuation ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param superannuation_id: Identifier for the superannuation (required)
        :type superannuation_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuperannuationObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "superannuation_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_superannuation" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["superannuation_id"] is not None:
            _path_params["SuperannuationID"] = _params["superannuation_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SuperannuationObject",
        }

        return await self.api_client.call_api(
            "/Superannuations/{SuperannuationID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_superannuations(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> Superannuations:  # noqa: E501
        """Retrieves superannuations  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Superannuations
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_superannuations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_superannuations_with_http_info(
            xero_tenant_id, page, **kwargs
        )  # noqa: E501

    async def get_superannuations_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves superannuations  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Superannuations, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_superannuations" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Superannuations",
        }

        return await self.api_client.call_api(
            "/Superannuations",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_timesheet(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        **kwargs,
    ) -> TimesheetObject:  # noqa: E501
        """Retrieves a specific timesheet by using a unique timesheet ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TimesheetObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_timesheet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_timesheet_with_http_info(
            xero_tenant_id, timesheet_id, **kwargs
        )  # noqa: E501

    async def get_timesheet_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a specific timesheet by using a unique timesheet ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TimesheetObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "timesheet_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_timesheet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["timesheet_id"] is not None:
            _path_params["TimesheetID"] = _params["timesheet_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TimesheetObject",
        }

        return await self.api_client.call_api(
            "/Timesheets/{TimesheetID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_timesheets(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        filter: Annotated[
            Optional[StrictStr],
            Field(description="Filter by employeeId and/or payrollCalendarId"),
        ] = None,
        status: Annotated[
            Optional[StrictStr],
            Field(
                description="filter results by any timesheets with a matching timesheet status"
            ),
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(
                description="filter results by any timesheets with a startDate on or after the provided date"
            ),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(
                description="filter results by any timesheets with a endDate on or before the provided date"
            ),
        ] = None,
        sort: Annotated[
            Optional[StrictStr],
            Field(
                description="sort the order of timesheets returned. The default is based on the timesheets createdDate, sorted oldest to newest. Currently, the only other option is to reverse the order based on the timesheets startDate, sorted newest to oldest."
            ),
        ] = None,
        **kwargs,
    ) -> Timesheets:  # noqa: E501
        """Retrieves timesheets  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param filter: Filter by employeeId and/or payrollCalendarId
        :type filter: str
        :param status: filter results by any timesheets with a matching timesheet status
        :type status: str
        :param start_date: filter results by any timesheets with a startDate on or after the provided date
        :type start_date: str
        :param end_date: filter results by any timesheets with a endDate on or before the provided date
        :type end_date: str
        :param sort: sort the order of timesheets returned. The default is based on the timesheets createdDate, sorted oldest to newest. Currently, the only other option is to reverse the order based on the timesheets startDate, sorted newest to oldest.
        :type sort: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Timesheets
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_timesheets_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_timesheets_with_http_info(
            xero_tenant_id, page, filter, status, start_date, end_date, sort, **kwargs
        )  # noqa: E501

    async def get_timesheets_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Page number which specifies the set of records to retrieve. By default the number of the records per set is 100."
            ),
        ] = None,
        filter: Annotated[
            Optional[StrictStr],
            Field(description="Filter by employeeId and/or payrollCalendarId"),
        ] = None,
        status: Annotated[
            Optional[StrictStr],
            Field(
                description="filter results by any timesheets with a matching timesheet status"
            ),
        ] = None,
        start_date: Annotated[
            Optional[StrictStr],
            Field(
                description="filter results by any timesheets with a startDate on or after the provided date"
            ),
        ] = None,
        end_date: Annotated[
            Optional[StrictStr],
            Field(
                description="filter results by any timesheets with a endDate on or before the provided date"
            ),
        ] = None,
        sort: Annotated[
            Optional[StrictStr],
            Field(
                description="sort the order of timesheets returned. The default is based on the timesheets createdDate, sorted oldest to newest. Currently, the only other option is to reverse the order based on the timesheets startDate, sorted newest to oldest."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves timesheets  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param page: Page number which specifies the set of records to retrieve. By default the number of the records per set is 100.
        :type page: int
        :param filter: Filter by employeeId and/or payrollCalendarId
        :type filter: str
        :param status: filter results by any timesheets with a matching timesheet status
        :type status: str
        :param start_date: filter results by any timesheets with a startDate on or after the provided date
        :type start_date: str
        :param end_date: filter results by any timesheets with a endDate on or before the provided date
        :type end_date: str
        :param sort: sort the order of timesheets returned. The default is based on the timesheets createdDate, sorted oldest to newest. Currently, the only other option is to reverse the order based on the timesheets startDate, sorted newest to oldest.
        :type sort: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Timesheets, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "page",
            "filter",
            "status",
            "start_date",
            "end_date",
            "sort",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_timesheets" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("filter") is not None:  # noqa: E501
            _query_params.append(("filter", _params["filter"]))

        if _params.get("status") is not None:  # noqa: E501
            _query_params.append(("status", _params["status"]))

        if _params.get("start_date") is not None:  # noqa: E501
            _query_params.append(("startDate", _params["start_date"]))

        if _params.get("end_date") is not None:  # noqa: E501
            _query_params.append(("endDate", _params["end_date"]))

        if _params.get("sort") is not None:  # noqa: E501
            _query_params.append(("sort", _params["sort"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Timesheets",
        }

        return await self.api_client.call_api(
            "/Timesheets",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_tracking_categories(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> TrackingCategories:  # noqa: E501
        """Retrieves tracking categories  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingCategories
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_tracking_categories_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_tracking_categories_with_http_info(
            xero_tenant_id, **kwargs
        )  # noqa: E501

    async def get_tracking_categories_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves tracking categories  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tracking_categories" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TrackingCategories",
        }

        return await self.api_client.call_api(
            "/Settings/TrackingCategories",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def revert_timesheet(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TimesheetObject:  # noqa: E501
        """Reverts a timesheet to draft  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TimesheetObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the revert_timesheet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.revert_timesheet_with_http_info(
            xero_tenant_id, timesheet_id, idempotency_key, **kwargs
        )  # noqa: E501

    async def revert_timesheet_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Reverts a timesheet to draft  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TimesheetObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "timesheet_id", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revert_timesheet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["timesheet_id"] is not None:
            _path_params["TimesheetID"] = _params["timesheet_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TimesheetObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Timesheets/{TimesheetID}/RevertToDraft",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_employee(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee: Employee,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeObject:  # noqa: E501
        """Updates an existing employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee: (required)
        :type employee: Employee
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_employee_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_employee_with_http_info(
            xero_tenant_id, employee_id, employee, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_employee_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee: Employee,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates an existing employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee: (required)
        :type employee: Employee
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "employee", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_employee" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee"] is not None:
            _body_params = _params["employee"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_employee_earnings_template(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        pay_template_earning_id: Annotated[
            StrictStr,
            Field(..., description="Id for single pay template earnings object"),
        ],
        earnings_template: EarningsTemplate,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EarningsTemplateObject:  # noqa: E501
        """Updates an earnings template records for an employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param pay_template_earning_id: Id for single pay template earnings object (required)
        :type pay_template_earning_id: str
        :param earnings_template: (required)
        :type earnings_template: EarningsTemplate
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EarningsTemplateObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_employee_earnings_template_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_employee_earnings_template_with_http_info(
            xero_tenant_id,
            employee_id,
            pay_template_earning_id,
            earnings_template,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_employee_earnings_template_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        pay_template_earning_id: Annotated[
            StrictStr,
            Field(..., description="Id for single pay template earnings object"),
        ],
        earnings_template: EarningsTemplate,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates an earnings template records for an employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param pay_template_earning_id: Id for single pay template earnings object (required)
        :type pay_template_earning_id: str
        :param earnings_template: (required)
        :type earnings_template: EarningsTemplate
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EarningsTemplateObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "pay_template_earning_id",
            "earnings_template",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_employee_earnings_template" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        if _params["pay_template_earning_id"] is not None:
            _path_params["PayTemplateEarningID"] = _params["pay_template_earning_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["earnings_template"] is not None:
            _body_params = _params["earnings_template"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EarningsTemplateObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/PayTemplates/Earnings/{PayTemplateEarningID}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_employee_leave(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        leave_id: Annotated[
            StrictStr, Field(..., description="Leave id for single object")
        ],
        employee_leave: EmployeeLeave,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeLeaveObject:  # noqa: E501
        """Updates leave records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param leave_id: Leave id for single object (required)
        :type leave_id: str
        :param employee_leave: (required)
        :type employee_leave: EmployeeLeave
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeLeaveObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_employee_leave_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_employee_leave_with_http_info(
            xero_tenant_id,
            employee_id,
            leave_id,
            employee_leave,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_employee_leave_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        leave_id: Annotated[
            StrictStr, Field(..., description="Leave id for single object")
        ],
        employee_leave: EmployeeLeave,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates leave records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param leave_id: Leave id for single object (required)
        :type leave_id: str
        :param employee_leave: (required)
        :type employee_leave: EmployeeLeave
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeLeaveObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "leave_id",
            "employee_leave",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_employee_leave" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        if _params["leave_id"] is not None:
            _path_params["LeaveID"] = _params["leave_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee_leave"] is not None:
            _body_params = _params["employee_leave"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeLeaveObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Leave/{LeaveID}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_employee_salary_and_wage(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        salary_and_wages_id: Annotated[
            StrictStr,
            Field(..., description="Id for single pay template earnings object"),
        ],
        salary_and_wage: SalaryAndWage,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> SalaryAndWageObject:  # noqa: E501
        """Updates an employee's salary and wages record  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param salary_and_wages_id: Id for single pay template earnings object (required)
        :type salary_and_wages_id: str
        :param salary_and_wage: (required)
        :type salary_and_wage: SalaryAndWage
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SalaryAndWageObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_employee_salary_and_wage_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_employee_salary_and_wage_with_http_info(
            xero_tenant_id,
            employee_id,
            salary_and_wages_id,
            salary_and_wage,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_employee_salary_and_wage_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        salary_and_wages_id: Annotated[
            StrictStr,
            Field(..., description="Id for single pay template earnings object"),
        ],
        salary_and_wage: SalaryAndWage,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates an employee's salary and wages record  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param salary_and_wages_id: Id for single pay template earnings object (required)
        :type salary_and_wages_id: str
        :param salary_and_wage: (required)
        :type salary_and_wage: SalaryAndWage
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SalaryAndWageObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "salary_and_wages_id",
            "salary_and_wage",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_employee_salary_and_wage" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        if _params["salary_and_wages_id"] is not None:
            _path_params["SalaryAndWagesID"] = _params["salary_and_wages_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["salary_and_wage"] is not None:
            _body_params = _params["salary_and_wage"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SalaryAndWageObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/SalaryAndWages/{SalaryAndWagesID}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_employee_tax(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_tax: EmployeeTax,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> EmployeeTaxObject:  # noqa: E501
        """Updates the tax records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_tax: (required)
        :type employee_tax: EmployeeTax
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EmployeeTaxObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_employee_tax_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_employee_tax_with_http_info(
            xero_tenant_id, employee_id, employee_tax, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_employee_tax_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee_tax: EmployeeTax,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates the tax records for a specific employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee_tax: (required)
        :type employee_tax: EmployeeTax
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EmployeeTaxObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "employee_id",
            "employee_tax",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_employee_tax" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee_tax"] is not None:
            _body_params = _params["employee_tax"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "EmployeeTaxObject",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}/Tax",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_pay_run(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr, Field(..., description="Identifier for the pay run")
        ],
        pay_run: PayRun,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PayRunObject:  # noqa: E501
        """Updates a pay run  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: Identifier for the pay run (required)
        :type pay_run_id: str
        :param pay_run: (required)
        :type pay_run: PayRun
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRunObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_pay_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_pay_run_with_http_info(
            xero_tenant_id, pay_run_id, pay_run, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_pay_run_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr, Field(..., description="Identifier for the pay run")
        ],
        pay_run: PayRun,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a pay run  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: Identifier for the pay run (required)
        :type pay_run_id: str
        :param pay_run: (required)
        :type pay_run: PayRun
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRunObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_run_id", "pay_run", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_pay_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["pay_run_id"] is not None:
            _path_params["PayRunID"] = _params["pay_run_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["pay_run"] is not None:
            _body_params = _params["pay_run"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRunObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/PayRuns/{PayRunID}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_pay_slip_line_items(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_slip_id: Annotated[
            StrictStr, Field(..., description="Identifier for the payslip")
        ],
        pay_slip: PaySlip,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PaySlipObject:  # noqa: E501
        """Creates an employee pay slip  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_slip_id: Identifier for the payslip (required)
        :type pay_slip_id: str
        :param pay_slip: (required)
        :type pay_slip: PaySlip
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaySlipObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_pay_slip_line_items_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_pay_slip_line_items_with_http_info(
            xero_tenant_id, pay_slip_id, pay_slip, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_pay_slip_line_items_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_slip_id: Annotated[
            StrictStr, Field(..., description="Identifier for the payslip")
        ],
        pay_slip: PaySlip,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates an employee pay slip  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_slip_id: Identifier for the payslip (required)
        :type pay_slip_id: str
        :param pay_slip: (required)
        :type pay_slip: PaySlip
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaySlipObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_slip_id", "pay_slip", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_pay_slip_line_items" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["pay_slip_id"] is not None:
            _path_params["PaySlipID"] = _params["pay_slip_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["pay_slip"] is not None:
            _body_params = _params["pay_slip"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PaySlipObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/PaySlips/{PaySlipID}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_timesheet_line(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        timesheet_line_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet line")
        ],
        timesheet_line: TimesheetLine,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> TimesheetLineObject:  # noqa: E501
        """Updates a timesheet line for a specific timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param timesheet_line_id: Identifier for the timesheet line (required)
        :type timesheet_line_id: str
        :param timesheet_line: (required)
        :type timesheet_line: TimesheetLine
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TimesheetLineObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_timesheet_line_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_timesheet_line_with_http_info(
            xero_tenant_id,
            timesheet_id,
            timesheet_line_id,
            timesheet_line,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_timesheet_line_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet")
        ],
        timesheet_line_id: Annotated[
            StrictStr, Field(..., description="Identifier for the timesheet line")
        ],
        timesheet_line: TimesheetLine,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a timesheet line for a specific timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Identifier for the timesheet (required)
        :type timesheet_id: str
        :param timesheet_line_id: Identifier for the timesheet line (required)
        :type timesheet_line_id: str
        :param timesheet_line: (required)
        :type timesheet_line: TimesheetLine
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TimesheetLineObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "timesheet_id",
            "timesheet_line_id",
            "timesheet_line",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_timesheet_line" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["timesheet_id"] is not None:
            _path_params["TimesheetID"] = _params["timesheet_id"]

        if _params["timesheet_line_id"] is not None:
            _path_params["TimesheetLineID"] = _params["timesheet_line_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["timesheet_line"] is not None:
            _body_params = _params["timesheet_line"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TimesheetLineObject",
            "400": "Problem",
        }

        return await self.api_client.call_api(
            "/Timesheets/{TimesheetID}/Lines/{TimesheetLineID}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
