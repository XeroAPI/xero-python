"""
    Xero Payroll AU API

    This is the Xero Payroll API for orgs in Australia region.

    The version of the OpenAPI document: 6.3.0
    Contact: api@xero.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import importlib
import re  # noqa: F401
from datetime import datetime
from typing import Optional

from pydantic import (
    Field,
    StrictInt,
    StrictStr,
    conlist,
)
from typing_extensions import Annotated

from xero_python.api_client import ApiClient, ApiResponse, ModelFinder
from xero_python.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError,
)
from xero_python.payrollau.models.employee import Employee
from xero_python.payrollau.models.employees import Employees
from xero_python.payrollau.models.leave_application import LeaveApplication
from xero_python.payrollau.models.leave_applications import LeaveApplications
from xero_python.payrollau.models.pay_item import PayItem
from xero_python.payrollau.models.pay_items import PayItems
from xero_python.payrollau.models.pay_run import PayRun
from xero_python.payrollau.models.pay_runs import PayRuns
from xero_python.payrollau.models.payroll_calendar import PayrollCalendar
from xero_python.payrollau.models.payroll_calendars import PayrollCalendars
from xero_python.payrollau.models.payslip_lines import PayslipLines
from xero_python.payrollau.models.payslip_object import PayslipObject
from xero_python.payrollau.models.payslips import Payslips
from xero_python.payrollau.models.settings_object import SettingsObject
from xero_python.payrollau.models.super_fund import SuperFund
from xero_python.payrollau.models.super_fund_products import SuperFundProducts
from xero_python.payrollau.models.super_funds import SuperFunds
from xero_python.payrollau.models.timesheet import Timesheet
from xero_python.payrollau.models.timesheet_object import TimesheetObject
from xero_python.payrollau.models.timesheets import Timesheets


class PayrollAuApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    base_url = "https://api.xero.com/payroll.xro/1.0"
    models_module = importlib.import_module("xero_python.payrollau.models")

    def __init__(self, api_client=None, base_url: str | None = None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client
        self.base_url = base_url or self.base_url

    def get_model_finder(self):
        return ModelFinder(self.models_module)

    async def approve_leave_application(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application_id: Annotated[
            StrictStr, Field(..., description="Leave Application id for single object")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> LeaveApplications:  # noqa: E501
        """Approve a requested leave application by a unique leave application id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application_id: Leave Application id for single object (required)
        :type leave_application_id: str
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveApplications
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the approve_leave_application_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.approve_leave_application_with_http_info(
            xero_tenant_id, leave_application_id, idempotency_key, **kwargs
        )  # noqa: E501

    async def approve_leave_application_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application_id: Annotated[
            StrictStr, Field(..., description="Leave Application id for single object")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Approve a requested leave application by a unique leave application id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application_id: Leave Application id for single object (required)
        :type leave_application_id: str
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveApplications, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "leave_application_id", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method approve_leave_application" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["leave_application_id"] is not None:
            _path_params["LeaveApplicationID"] = _params["leave_application_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveApplications",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/LeaveApplications/{LeaveApplicationID}/approve",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_employee(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee: conlist(Employee),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Employees:  # noqa: E501
        """Creates a payroll employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee: (required)
        :type employee: List[Employee]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Employees
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_employee_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_employee_with_http_info(
            xero_tenant_id, employee, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_employee_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee: conlist(Employee),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a payroll employee  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee: (required)
        :type employee: List[Employee]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee"] is not None:
            _body_params = _params["employee"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Employees",
            "400": None,
        }

        return await self.api_client.call_api(
            "/Employees",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_leave_application(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application: conlist(LeaveApplication),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> LeaveApplications:  # noqa: E501
        """Creates a leave application  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application: (required)
        :type leave_application: List[LeaveApplication]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveApplications
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_leave_application_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_leave_application_with_http_info(
            xero_tenant_id, leave_application, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_leave_application_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application: conlist(LeaveApplication),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a leave application  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application: (required)
        :type leave_application: List[LeaveApplication]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveApplications, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "leave_application", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_leave_application" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["leave_application"] is not None:
            _body_params = _params["leave_application"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveApplications",
            "400": None,
        }

        return await self.api_client.call_api(
            "/LeaveApplications",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_pay_item(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_item: PayItem,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PayItems:  # noqa: E501
        """Creates a pay item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_item: (required)
        :type pay_item: PayItem
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayItems
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_pay_item_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_pay_item_with_http_info(
            xero_tenant_id, pay_item, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_pay_item_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_item: PayItem,
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a pay item  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_item: (required)
        :type pay_item: PayItem
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayItems, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_item", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pay_item" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["pay_item"] is not None:
            _body_params = _params["pay_item"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayItems",
            "400": None,
        }

        return await self.api_client.call_api(
            "/PayItems",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_pay_run(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run: conlist(PayRun),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PayRuns:  # noqa: E501
        """Creates a pay run  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run: (required)
        :type pay_run: List[PayRun]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRuns
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_pay_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_pay_run_with_http_info(
            xero_tenant_id, pay_run, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_pay_run_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run: conlist(PayRun),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a pay run  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run: (required)
        :type pay_run: List[PayRun]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRuns, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_run", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pay_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["pay_run"] is not None:
            _body_params = _params["pay_run"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRuns",
            "400": None,
        }

        return await self.api_client.call_api(
            "/PayRuns",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_payroll_calendar(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payroll_calendar: conlist(PayrollCalendar),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PayrollCalendars:  # noqa: E501
        """Creates a Payroll Calendar  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payroll_calendar: (required)
        :type payroll_calendar: List[PayrollCalendar]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayrollCalendars
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_payroll_calendar_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_payroll_calendar_with_http_info(
            xero_tenant_id, payroll_calendar, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_payroll_calendar_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payroll_calendar: conlist(PayrollCalendar),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a Payroll Calendar  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payroll_calendar: (required)
        :type payroll_calendar: List[PayrollCalendar]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayrollCalendars, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "payroll_calendar", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_payroll_calendar" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["payroll_calendar"] is not None:
            _body_params = _params["payroll_calendar"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayrollCalendars",
            "400": None,
        }

        return await self.api_client.call_api(
            "/PayrollCalendars",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_superfund(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        super_fund: conlist(SuperFund),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> SuperFunds:  # noqa: E501
        """Creates a superfund  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param super_fund: (required)
        :type super_fund: List[SuperFund]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuperFunds
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_superfund_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_superfund_with_http_info(
            xero_tenant_id, super_fund, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_superfund_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        super_fund: conlist(SuperFund),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a superfund  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param super_fund: (required)
        :type super_fund: List[SuperFund]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuperFunds, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "super_fund", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_superfund" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["super_fund"] is not None:
            _body_params = _params["super_fund"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SuperFunds",
            "400": None,
        }

        return await self.api_client.call_api(
            "/Superfunds",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def create_timesheet(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet: conlist(Timesheet),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Timesheets:  # noqa: E501
        """Creates a timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet: (required)
        :type timesheet: List[Timesheet]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Timesheets
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_timesheet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.create_timesheet_with_http_info(
            xero_tenant_id, timesheet, idempotency_key, **kwargs
        )  # noqa: E501

    async def create_timesheet_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet: conlist(Timesheet),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Creates a timesheet  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet: (required)
        :type timesheet: List[Timesheet]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Timesheets, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "timesheet", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_timesheet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["timesheet"] is not None:
            _body_params = _params["timesheet"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Timesheets",
            "400": None,
        }

        return await self.api_client.call_api(
            "/Timesheets",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employee(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> Employees:  # noqa: E501
        """Retrieves an employee's detail by unique employee id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Employees
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employee_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employee_with_http_info(
            xero_tenant_id, employee_id, **kwargs
        )  # noqa: E501

    async def get_employee_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves an employee's detail by unique employee id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Employees",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_employees(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 employees will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> Employees:  # noqa: E501
        """Searches payroll employees  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 employees will be returned in a single API call
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Employees
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_employees_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_employees_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, **kwargs
        )  # noqa: E501

    async def get_employees_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 employees will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Searches payroll employees  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 employees will be returned in a single API call
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employees" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Employees",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/Employees",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_leave_application(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application_id: Annotated[
            StrictStr, Field(..., description="Leave Application id for single object")
        ],
        **kwargs,
    ) -> LeaveApplications:  # noqa: E501
        """Retrieves a leave application by a unique leave application id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application_id: Leave Application id for single object (required)
        :type leave_application_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveApplications
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_leave_application_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_leave_application_with_http_info(
            xero_tenant_id, leave_application_id, **kwargs
        )  # noqa: E501

    async def get_leave_application_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application_id: Annotated[
            StrictStr, Field(..., description="Leave Application id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a leave application by a unique leave application id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application_id: Leave Application id for single object (required)
        :type leave_application_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveApplications, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "leave_application_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_leave_application" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["leave_application_id"] is not None:
            _path_params["LeaveApplicationID"] = _params["leave_application_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveApplications",
        }

        return await self.api_client.call_api(
            "/LeaveApplications/{LeaveApplicationID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_leave_applications(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 objects will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> LeaveApplications:  # noqa: E501
        """Retrieves leave applications  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 objects will be returned in a single API call
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveApplications
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_leave_applications_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_leave_applications_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, **kwargs
        )  # noqa: E501

    async def get_leave_applications_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 objects will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves leave applications  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 objects will be returned in a single API call
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveApplications, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_leave_applications" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveApplications",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/LeaveApplications",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_leave_applications_v2(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 objects will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> LeaveApplications:  # noqa: E501
        """Retrieves leave applications including leave requests  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 objects will be returned in a single API call
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveApplications
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_leave_applications_v2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_leave_applications_v2_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, **kwargs
        )  # noqa: E501

    async def get_leave_applications_v2_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 objects will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves leave applications including leave requests  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 objects will be returned in a single API call
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveApplications, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_leave_applications_v2" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveApplications",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/LeaveApplications/v2",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_pay_items(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 objects will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> PayItems:  # noqa: E501
        """Retrieves pay items  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 objects will be returned in a single API call
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayItems
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_pay_items_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_pay_items_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, **kwargs
        )  # noqa: E501

    async def get_pay_items_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 objects will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves pay items  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 objects will be returned in a single API call
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayItems, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pay_items" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayItems",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/PayItems",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_pay_run(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr, Field(..., description="PayRun id for single object")
        ],
        **kwargs,
    ) -> PayRuns:  # noqa: E501
        """Retrieves a pay run by using a unique pay run id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: PayRun id for single object (required)
        :type pay_run_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRuns
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_pay_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_pay_run_with_http_info(
            xero_tenant_id, pay_run_id, **kwargs
        )  # noqa: E501

    async def get_pay_run_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr, Field(..., description="PayRun id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a pay run by using a unique pay run id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: PayRun id for single object (required)
        :type pay_run_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRuns, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_run_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pay_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["pay_run_id"] is not None:
            _path_params["PayRunID"] = _params["pay_run_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRuns",
        }

        return await self.api_client.call_api(
            "/PayRuns/{PayRunID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_pay_runs(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 PayRuns will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> PayRuns:  # noqa: E501
        """Retrieves pay runs  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 PayRuns will be returned in a single API call
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRuns
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_pay_runs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_pay_runs_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, **kwargs
        )  # noqa: E501

    async def get_pay_runs_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 PayRuns will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves pay runs  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 PayRuns will be returned in a single API call
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRuns, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pay_runs" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRuns",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/PayRuns",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_payroll_calendar(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payroll_calendar_id: Annotated[
            StrictStr, Field(..., description="Payroll Calendar id for single object")
        ],
        **kwargs,
    ) -> PayrollCalendars:  # noqa: E501
        """Retrieves payroll calendar by using a unique payroll calendar ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payroll_calendar_id: Payroll Calendar id for single object (required)
        :type payroll_calendar_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayrollCalendars
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_payroll_calendar_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_payroll_calendar_with_http_info(
            xero_tenant_id, payroll_calendar_id, **kwargs
        )  # noqa: E501

    async def get_payroll_calendar_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payroll_calendar_id: Annotated[
            StrictStr, Field(..., description="Payroll Calendar id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves payroll calendar by using a unique payroll calendar ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payroll_calendar_id: Payroll Calendar id for single object (required)
        :type payroll_calendar_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayrollCalendars, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "payroll_calendar_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payroll_calendar" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["payroll_calendar_id"] is not None:
            _path_params["PayrollCalendarID"] = _params["payroll_calendar_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayrollCalendars",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/PayrollCalendars/{PayrollCalendarID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_payroll_calendars(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 objects will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> PayrollCalendars:  # noqa: E501
        """Retrieves payroll calendars  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 objects will be returned in a single API call
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayrollCalendars
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_payroll_calendars_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_payroll_calendars_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, **kwargs
        )  # noqa: E501

    async def get_payroll_calendars_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 objects will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves payroll calendars  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 objects will be returned in a single API call
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayrollCalendars, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payroll_calendars" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayrollCalendars",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/PayrollCalendars",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_payslip(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payslip_id: Annotated[
            StrictStr, Field(..., description="Payslip id for single object")
        ],
        **kwargs,
    ) -> PayslipObject:  # noqa: E501
        """Retrieves for a payslip by a unique payslip id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payslip_id: Payslip id for single object (required)
        :type payslip_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayslipObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_payslip_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_payslip_with_http_info(
            xero_tenant_id, payslip_id, **kwargs
        )  # noqa: E501

    async def get_payslip_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payslip_id: Annotated[
            StrictStr, Field(..., description="Payslip id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves for a payslip by a unique payslip id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payslip_id: Payslip id for single object (required)
        :type payslip_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayslipObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "payslip_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payslip" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["payslip_id"] is not None:
            _path_params["PayslipID"] = _params["payslip_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayslipObject",
        }

        return await self.api_client.call_api(
            "/Payslip/{PayslipID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_settings(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> SettingsObject:  # noqa: E501
        """Retrieves payroll settings  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SettingsObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_settings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_settings_with_http_info(xero_tenant_id, **kwargs)  # noqa: E501

    async def get_settings_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves payroll settings  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SettingsObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_settings" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SettingsObject",
        }

        return await self.api_client.call_api(
            "/Settings",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_superfund(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        super_fund_id: Annotated[
            StrictStr, Field(..., description="Superfund id for single object")
        ],
        **kwargs,
    ) -> SuperFunds:  # noqa: E501
        """Retrieves a superfund by using a unique superfund ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param super_fund_id: Superfund id for single object (required)
        :type super_fund_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuperFunds
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_superfund_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_superfund_with_http_info(
            xero_tenant_id, super_fund_id, **kwargs
        )  # noqa: E501

    async def get_superfund_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        super_fund_id: Annotated[
            StrictStr, Field(..., description="Superfund id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a superfund by using a unique superfund ID  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param super_fund_id: Superfund id for single object (required)
        :type super_fund_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuperFunds, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "super_fund_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_superfund" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["super_fund_id"] is not None:
            _path_params["SuperFundID"] = _params["super_fund_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SuperFunds",
        }

        return await self.api_client.call_api(
            "/Superfunds/{SuperFundID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_superfund_products(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        abn: Annotated[
            Optional[StrictStr], Field(description="The ABN of the Regulated SuperFund")
        ] = None,
        usi: Annotated[
            Optional[StrictStr], Field(description="The USI of the Regulated SuperFund")
        ] = None,
        **kwargs,
    ) -> SuperFundProducts:  # noqa: E501
        """Retrieves superfund products  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param abn: The ABN of the Regulated SuperFund
        :type abn: str
        :param usi: The USI of the Regulated SuperFund
        :type usi: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuperFundProducts
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_superfund_products_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_superfund_products_with_http_info(
            xero_tenant_id, abn, usi, **kwargs
        )  # noqa: E501

    async def get_superfund_products_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        abn: Annotated[
            Optional[StrictStr], Field(description="The ABN of the Regulated SuperFund")
        ] = None,
        usi: Annotated[
            Optional[StrictStr], Field(description="The USI of the Regulated SuperFund")
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves superfund products  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param abn: The ABN of the Regulated SuperFund
        :type abn: str
        :param usi: The USI of the Regulated SuperFund
        :type usi: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuperFundProducts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "abn", "usi"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_superfund_products" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("abn") is not None:  # noqa: E501
            _query_params.append(("ABN", _params["abn"]))

        if _params.get("usi") is not None:  # noqa: E501
            _query_params.append(("USI", _params["usi"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SuperFundProducts",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/SuperfundProducts",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_superfunds(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 SuperFunds will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> SuperFunds:  # noqa: E501
        """Retrieves superfunds  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 SuperFunds will be returned in a single API call
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuperFunds
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_superfunds_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_superfunds_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, **kwargs
        )  # noqa: E501

    async def get_superfunds_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 SuperFunds will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves superfunds  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 SuperFunds will be returned in a single API call
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuperFunds, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_superfunds" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SuperFunds",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/Superfunds",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_timesheet(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Timesheet id for single object")
        ],
        **kwargs,
    ) -> TimesheetObject:  # noqa: E501
        """Retrieves a timesheet by using a unique timesheet id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Timesheet id for single object (required)
        :type timesheet_id: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TimesheetObject
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_timesheet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_timesheet_with_http_info(
            xero_tenant_id, timesheet_id, **kwargs
        )  # noqa: E501

    async def get_timesheet_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Timesheet id for single object")
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves a timesheet by using a unique timesheet id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Timesheet id for single object (required)
        :type timesheet_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TimesheetObject, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "timesheet_id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_timesheet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["timesheet_id"] is not None:
            _path_params["TimesheetID"] = _params["timesheet_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "TimesheetObject",
        }

        return await self.api_client.call_api(
            "/Timesheets/{TimesheetID}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def get_timesheets(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 timesheets will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> Timesheets:  # noqa: E501
        """Retrieves timesheets  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 timesheets will be returned in a single API call
        :type page: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Timesheets
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_timesheets_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_timesheets_with_http_info(
            xero_tenant_id, if_modified_since, where, order, page, **kwargs
        )  # noqa: E501

    async def get_timesheets_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        if_modified_since: Annotated[
            Optional[datetime],
            Field(
                description="Only records created or modified since this timestamp will be returned"
            ),
        ] = None,
        where: Annotated[
            Optional[StrictStr], Field(description="Filter by an any element")
        ] = None,
        order: Annotated[
            Optional[StrictStr], Field(description="Order by an any element")
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="e.g. page=1  Up to 100 timesheets will be returned in a single API call"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Retrieves timesheets  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param if_modified_since: Only records created or modified since this timestamp will be returned
        :type if_modified_since: datetime
        :param where: Filter by an any element
        :type where: str
        :param order: Order by an any element
        :type order: str
        :param page: e.g. page=1  Up to 100 timesheets will be returned in a single API call
        :type page: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Timesheets, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "if_modified_since", "where", "order", "page"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_timesheets" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("where") is not None:  # noqa: E501
            _query_params.append(("where", _params["where"]))

        if _params.get("order") is not None:  # noqa: E501
            _query_params.append(("order", _params["order"]))

        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["if_modified_since"] is not None:
            _header_params["If-Modified-Since"] = _params["if_modified_since"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Timesheets",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/Timesheets",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def reject_leave_application(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application_id: Annotated[
            StrictStr, Field(..., description="Leave Application id for single object")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> LeaveApplications:  # noqa: E501
        """Reject a leave application by a unique leave application id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application_id: Leave Application id for single object (required)
        :type leave_application_id: str
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveApplications
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the reject_leave_application_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.reject_leave_application_with_http_info(
            xero_tenant_id, leave_application_id, idempotency_key, **kwargs
        )  # noqa: E501

    async def reject_leave_application_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application_id: Annotated[
            StrictStr, Field(..., description="Leave Application id for single object")
        ],
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Reject a leave application by a unique leave application id  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application_id: Leave Application id for single object (required)
        :type leave_application_id: str
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveApplications, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "leave_application_id", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reject_leave_application" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["leave_application_id"] is not None:
            _path_params["LeaveApplicationID"] = _params["leave_application_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveApplications",
            "400": "APIException",
        }

        return await self.api_client.call_api(
            "/LeaveApplications/{LeaveApplicationID}/reject",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_employee(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee: conlist(Employee),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Employees:  # noqa: E501
        """Updates an employee's detail  # noqa: E501

        Update properties on a single employee  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee: (required)
        :type employee: List[Employee]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Employees
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_employee_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_employee_with_http_info(
            xero_tenant_id, employee_id, employee, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_employee_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        employee_id: Annotated[
            StrictStr, Field(..., description="Employee id for single object")
        ],
        employee: conlist(Employee),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates an employee's detail  # noqa: E501

        Update properties on a single employee  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param employee_id: Employee id for single object (required)
        :type employee_id: str
        :param employee: (required)
        :type employee: List[Employee]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "employee_id", "employee", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_employee" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["employee_id"] is not None:
            _path_params["EmployeeID"] = _params["employee_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["employee"] is not None:
            _body_params = _params["employee"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Employees",
        }

        return await self.api_client.call_api(
            "/Employees/{EmployeeID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_leave_application(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application_id: Annotated[
            StrictStr, Field(..., description="Leave Application id for single object")
        ],
        leave_application: conlist(LeaveApplication),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> LeaveApplications:  # noqa: E501
        """Updates a specific leave application  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application_id: Leave Application id for single object (required)
        :type leave_application_id: str
        :param leave_application: (required)
        :type leave_application: List[LeaveApplication]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LeaveApplications
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_leave_application_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_leave_application_with_http_info(
            xero_tenant_id,
            leave_application_id,
            leave_application,
            idempotency_key,
            **kwargs,
        )  # noqa: E501

    async def update_leave_application_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        leave_application_id: Annotated[
            StrictStr, Field(..., description="Leave Application id for single object")
        ],
        leave_application: conlist(LeaveApplication),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a specific leave application  # noqa: E501


        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param leave_application_id: Leave Application id for single object (required)
        :type leave_application_id: str
        :param leave_application: (required)
        :type leave_application: List[LeaveApplication]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LeaveApplications, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "leave_application_id",
            "leave_application",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_leave_application" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["leave_application_id"] is not None:
            _path_params["LeaveApplicationID"] = _params["leave_application_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["leave_application"] is not None:
            _body_params = _params["leave_application"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "LeaveApplications",
            "400": None,
        }

        return await self.api_client.call_api(
            "/LeaveApplications/{LeaveApplicationID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_pay_run(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr, Field(..., description="PayRun id for single object")
        ],
        pay_run: conlist(PayRun),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> PayRuns:  # noqa: E501
        """Updates a pay run  # noqa: E501

        Update properties on a single PayRun  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: PayRun id for single object (required)
        :type pay_run_id: str
        :param pay_run: (required)
        :type pay_run: List[PayRun]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayRuns
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_pay_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_pay_run_with_http_info(
            xero_tenant_id, pay_run_id, pay_run, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_pay_run_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        pay_run_id: Annotated[
            StrictStr, Field(..., description="PayRun id for single object")
        ],
        pay_run: conlist(PayRun),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a pay run  # noqa: E501

        Update properties on a single PayRun  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param pay_run_id: PayRun id for single object (required)
        :type pay_run_id: str
        :param pay_run: (required)
        :type pay_run: List[PayRun]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayRuns, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "pay_run_id", "pay_run", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_pay_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["pay_run_id"] is not None:
            _path_params["PayRunID"] = _params["pay_run_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["pay_run"] is not None:
            _body_params = _params["pay_run"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "PayRuns",
        }

        return await self.api_client.call_api(
            "/PayRuns/{PayRunID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_payslip(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payslip_id: Annotated[
            StrictStr, Field(..., description="Payslip id for single object")
        ],
        payslip_lines: conlist(PayslipLines),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Payslips:  # noqa: E501
        """Updates a payslip  # noqa: E501

        Update lines on a single payslips  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payslip_id: Payslip id for single object (required)
        :type payslip_id: str
        :param payslip_lines: (required)
        :type payslip_lines: List[PayslipLines]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Payslips
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_payslip_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_payslip_with_http_info(
            xero_tenant_id, payslip_id, payslip_lines, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_payslip_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        payslip_id: Annotated[
            StrictStr, Field(..., description="Payslip id for single object")
        ],
        payslip_lines: conlist(PayslipLines),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a payslip  # noqa: E501

        Update lines on a single payslips  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param payslip_id: Payslip id for single object (required)
        :type payslip_id: str
        :param payslip_lines: (required)
        :type payslip_lines: List[PayslipLines]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Payslips, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "payslip_id",
            "payslip_lines",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_payslip" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["payslip_id"] is not None:
            _path_params["PayslipID"] = _params["payslip_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["payslip_lines"] is not None:
            _body_params = _params["payslip_lines"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Payslips",
        }

        return await self.api_client.call_api(
            "/Payslip/{PayslipID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_superfund(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        super_fund_id: Annotated[
            StrictStr, Field(..., description="Superfund id for single object")
        ],
        super_fund: conlist(SuperFund),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> SuperFunds:  # noqa: E501
        """Updates a superfund  # noqa: E501

        Update properties on a single Superfund  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param super_fund_id: Superfund id for single object (required)
        :type super_fund_id: str
        :param super_fund: (required)
        :type super_fund: List[SuperFund]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuperFunds
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_superfund_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_superfund_with_http_info(
            xero_tenant_id, super_fund_id, super_fund, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_superfund_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        super_fund_id: Annotated[
            StrictStr, Field(..., description="Superfund id for single object")
        ],
        super_fund: conlist(SuperFund),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a superfund  # noqa: E501

        Update properties on a single Superfund  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param super_fund_id: Superfund id for single object (required)
        :type super_fund_id: str
        :param super_fund: (required)
        :type super_fund: List[SuperFund]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuperFunds, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "xero_tenant_id",
            "super_fund_id",
            "super_fund",
            "idempotency_key",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_superfund" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["super_fund_id"] is not None:
            _path_params["SuperFundID"] = _params["super_fund_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["super_fund"] is not None:
            _body_params = _params["super_fund"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "SuperFunds",
        }

        return await self.api_client.call_api(
            "/Superfunds/{SuperFundID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    async def update_timesheet(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Timesheet id for single object")
        ],
        timesheet: conlist(Timesheet),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> Timesheets:  # noqa: E501
        """Updates a timesheet  # noqa: E501

        Update properties on a single timesheet  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Timesheet id for single object (required)
        :type timesheet_id: str
        :param timesheet: (required)
        :type timesheet: List[Timesheet]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Timesheets
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_timesheet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.update_timesheet_with_http_info(
            xero_tenant_id, timesheet_id, timesheet, idempotency_key, **kwargs
        )  # noqa: E501

    async def update_timesheet_with_http_info(
        self,
        xero_tenant_id: Annotated[
            StrictStr, Field(..., description="Xero identifier for Tenant")
        ],
        timesheet_id: Annotated[
            StrictStr, Field(..., description="Timesheet id for single object")
        ],
        timesheet: conlist(Timesheet),
        idempotency_key: Annotated[
            Optional[StrictStr],
            Field(
                description="This allows you to safely retry requests without the risk of duplicate processing. 128 character max."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Updates a timesheet  # noqa: E501

        Update properties on a single timesheet  # noqa: E501

        :param xero_tenant_id: Xero identifier for Tenant (required)
        :type xero_tenant_id: str
        :param timesheet_id: Timesheet id for single object (required)
        :type timesheet_id: str
        :param timesheet: (required)
        :type timesheet: List[Timesheet]
        :param idempotency_key: This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
        :type idempotency_key: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Timesheets, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["xero_tenant_id", "timesheet_id", "timesheet", "idempotency_key"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_timesheet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["timesheet_id"] is not None:
            _path_params["TimesheetID"] = _params["timesheet_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["xero_tenant_id"] is not None:
            _header_params["Xero-Tenant-Id"] = _params["xero_tenant_id"]

        if _params["idempotency_key"] is not None:
            _header_params["Idempotency-Key"] = _params["idempotency_key"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["timesheet"] is not None:
            _body_params = _params["timesheet"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["OAuth2"]  # noqa: E501

        _response_types_map = {
            "200": "Timesheets",
        }

        return await self.api_client.call_api(
            "/Timesheets/{TimesheetID}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            response_model_finder=self.get_model_finder(),
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            _host=self.base_url,
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
